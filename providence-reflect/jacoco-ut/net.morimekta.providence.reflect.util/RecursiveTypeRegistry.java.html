<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RecursiveTypeRegistry.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Providence Utils : Reflection</a> &gt; <a href="index.source.html" class="el_package">net.morimekta.providence.reflect.util</a> &gt; <span class="el_source">RecursiveTypeRegistry.java</span></div><h1>RecursiveTypeRegistry.java</h1><pre class="source lang-java linenums">package net.morimekta.providence.reflect.util;

import net.morimekta.providence.descriptor.PDeclaredDescriptor;
import net.morimekta.providence.descriptor.PService;
import net.morimekta.providence.util.BaseTypeRegistry;

import javax.annotation.Nonnull;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * A registry that can reference each other recursively. Each registry will
 * have a specific package context, and needs to be built up in a recursive
 * manner. This way each type registry will only have access to the described
 * types actually referenced and included in the given thrift program file.
 */
public class RecursiveTypeRegistry extends BaseTypeRegistry {
    private final String                              localProgramContext;
    private final Map&lt;String, PDeclaredDescriptor&lt;?&gt;&gt; declaredTypes;
    private final Map&lt;String, PService&gt;               services;
    private final Map&lt;String, RecursiveTypeRegistry&gt;  includes;

<span class="fc" id="L24">    public RecursiveTypeRegistry(@Nonnull String localProgramContext) {</span>
<span class="fc" id="L25">        this.localProgramContext = localProgramContext;</span>
<span class="fc" id="L26">        this.declaredTypes       = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L27">        this.services            = new HashMap&lt;&gt;();</span>
<span class="fc" id="L28">        this.includes            = new HashMap&lt;&gt;();</span>
<span class="fc" id="L29">    }</span>

    public String getLocalProgramContext() {
<span class="fc" id="L32">        return localProgramContext;</span>
    }

    /**
     * Get the registry to be used for the specific program. Search through
     * all the included registries to find the best one.
     *
     * @param programName The program to find registry for.
     * @return The Recursive type registry or null of not found.
     */
    public RecursiveTypeRegistry getRegistryForProgramName(String programName) {
<span class="nc bnc" id="L43" title="All 2 branches missed.">        if (localProgramContext.equals(programName)) return this;</span>
<span class="nc bnc" id="L44" title="All 2 branches missed.">        for (RecursiveTypeRegistry registry : includes.values()) {</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">            if (registry.getLocalProgramContext().equals(programName)) {</span>
<span class="nc" id="L46">                return registry;</span>
            }
<span class="nc" id="L48">        }</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">        for (RecursiveTypeRegistry registry : includes.values()) {</span>
<span class="nc" id="L50">            RecursiveTypeRegistry tmp = registry.getRegistryForProgramName(programName);</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">            if (tmp != null) {</span>
<span class="nc" id="L52">                return tmp;</span>
            }
<span class="nc" id="L54">        }</span>
<span class="nc" id="L55">        return null;</span>
    }

    /**
     * Register a recursive included registry.
     *
     * @param programName The program to be included.
     * @param registry The registry for the given program.
     */
    public void registerInclude(String programName, RecursiveTypeRegistry registry) {
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">        if (registry == this) {</span>
<span class="nc" id="L66">            throw new IllegalArgumentException(&quot;Registering include back to itself: &quot; + programName);</span>
        }
<span class="fc bfc" id="L68" title="All 2 branches covered.">        if (includes.containsKey(programName)) {</span>
<span class="fc" id="L69">            return;</span>
        }
<span class="fc" id="L71">        includes.put(programName, registry);</span>
<span class="fc" id="L72">    }</span>

    @Nonnull
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T extends PDeclaredDescriptor&lt;T&gt;&gt; T getDeclaredType(@Nonnull String typeName,
                                                                @Nonnull String programContext) {
<span class="fc" id="L79">        String finalName = finalTypename(typeName, programContext);</span>

<span class="fc" id="L81">        String program = finalName.replaceAll(&quot;\\..*&quot;, &quot;&quot;);</span>
<span class="fc" id="L82">        String name = finalName.replaceAll(&quot;.*\\.&quot;, &quot;&quot;);</span>

<span class="pc bpc" id="L84" title="1 of 2 branches missed.">        if (localProgramContext.equals(program)) {</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">            if (declaredTypes.containsKey(name)) {</span>
<span class="fc" id="L86">                return (T) declaredTypes.get(name);</span>
            }
<span class="fc" id="L88">            throw new IllegalArgumentException(</span>
                    &quot;No such type \&quot;&quot; + name + &quot;\&quot; in program \&quot;&quot; + program + &quot;\&quot;&quot;);
        }
<span class="nc bnc" id="L91" title="All 2 branches missed.">        if (includes.containsKey(program)) {</span>
<span class="nc" id="L92">            return includes.get(program).getDeclaredType(name, program);</span>
        }
<span class="nc" id="L94">        throw new IllegalArgumentException(</span>
                &quot;No such program \&quot;&quot; + program + &quot;\&quot; known for type \&quot;&quot; + typeName + &quot;\&quot;&quot;);
    }

    @Nonnull
    @Override
    public PService getService(String serviceName, String programContext) {
<span class="fc" id="L101">        String finalName = qualifiedNameFromIdAndContext(serviceName, programContext);</span>

<span class="fc" id="L103">        String program = finalName.replaceAll(&quot;\\..*&quot;, &quot;&quot;);</span>
<span class="fc" id="L104">        String name = finalName.replaceAll(&quot;.*\\.&quot;, &quot;&quot;);</span>

<span class="fc bfc" id="L106" title="All 2 branches covered.">        if (localProgramContext.equals(program)) {</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">            if (services.containsKey(name)) {</span>
<span class="fc" id="L108">                return services.get(name);</span>
            }
<span class="fc" id="L110">            throw new IllegalArgumentException(&quot;No such service \&quot;&quot; + name + &quot;\&quot; in program \&quot;&quot; + program + &quot;\&quot;&quot;);</span>
        }
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">        if (includes.containsKey(program)) {</span>
<span class="fc" id="L113">            return includes.get(program).getService(name, program);</span>
        }
<span class="nc" id="L115">        throw new IllegalArgumentException(&quot;No such program \&quot;&quot; + program + &quot;\&quot; known for service \&quot;&quot; + serviceName + &quot;\&quot;&quot;);</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public boolean register(@Nonnull PService service) {
<span class="fc" id="L121">        String program = service.getProgramName();</span>

<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (!localProgramContext.equals(program)) {</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">            if (includes.containsKey(program)) {</span>
<span class="fc" id="L125">                includes.get(program).registerRecursively(service);</span>
<span class="fc" id="L126">                return true;</span>
            }
<span class="nc" id="L128">            throw new IllegalArgumentException(&quot;No such include \&quot;&quot; + program + &quot;\&quot; for type &quot; + service.getQualifiedName() + &quot; in &quot; + localProgramContext);</span>
        }
<span class="fc" id="L130">        String serviceName = service.getName();</span>

<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (services.containsKey(serviceName)) {</span>
<span class="fc" id="L133">            return false;</span>
        }
<span class="fc" id="L135">        services.put(serviceName, service);</span>
<span class="fc" id="L136">        return true;</span>
    }

    @Override
    public &lt;T&gt; boolean register(PDeclaredDescriptor&lt;T&gt; declaredType) {
<span class="fc" id="L141">        String program = declaredType.getProgramName();</span>

<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        if (!localProgramContext.equals(program)) {</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">            if (includes.containsKey(program)) {</span>
<span class="nc" id="L145">                includes.get(program).registerRecursively(declaredType);</span>
            }
<span class="nc" id="L147">            throw new IllegalArgumentException(&quot;No include for type: &quot; + declaredType.getQualifiedName());</span>
        }
<span class="fc" id="L149">        String typeName = declaredType.getName();</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">        if (declaredTypes.containsKey(typeName)) {</span>
<span class="nc" id="L151">            return false;</span>
        }

<span class="fc" id="L154">        declaredTypes.put(typeName, declaredType);</span>
<span class="fc" id="L155">        return true;</span>
    }

    protected boolean isEmpty() {
<span class="pc bpc" id="L159" title="3 of 4 branches missed.">        return declaredTypes.isEmpty() &amp;&amp; services.isEmpty();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>