<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HazelcastPortableProgramFormatter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Providence Generator : Java</a> &gt; <a href="index.source.html" class="el_package">net.morimekta.providence.generator.format.java.program.extras</a> &gt; <span class="el_source">HazelcastPortableProgramFormatter.java</span></div><h1>HazelcastPortableProgramFormatter.java</h1><pre class="source lang-java linenums">package net.morimekta.providence.generator.format.java.program.extras;

import net.morimekta.providence.PType;
import net.morimekta.providence.descriptor.PDeclaredDescriptor;
import net.morimekta.providence.descriptor.PDescriptor;
import net.morimekta.providence.descriptor.PList;
import net.morimekta.providence.descriptor.PSet;
import net.morimekta.providence.generator.GeneratorException;
import net.morimekta.providence.generator.GeneratorOptions;
import net.morimekta.providence.generator.format.java.JavaOptions;
import net.morimekta.providence.generator.format.java.messages.extras.HazelcastPortableMessageFormatter;
import net.morimekta.providence.generator.format.java.shared.BaseProgramFormatter;
import net.morimekta.providence.generator.format.java.utils.BlockCommentBuilder;
import net.morimekta.providence.generator.format.java.utils.JField;
import net.morimekta.providence.generator.format.java.utils.JHelper;
import net.morimekta.providence.generator.format.java.utils.JMessage;
import net.morimekta.providence.reflect.contained.CConst;
import net.morimekta.providence.reflect.contained.CProgram;
import net.morimekta.providence.reflect.contained.CStructDescriptor;
import net.morimekta.providence.util.ThriftAnnotation;
import net.morimekta.util.io.IndentedPrintWriter;

import com.hazelcast.config.Config;
import com.hazelcast.nio.serialization.ClassDefinition;
import com.hazelcast.nio.serialization.ClassDefinitionBuilder;
import com.hazelcast.nio.serialization.Portable;
import com.hazelcast.nio.serialization.PortableFactory;

import javax.annotation.Generated;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import static net.morimekta.providence.generator.format.java.utils.JUtils.camelCase;
import static net.morimekta.providence.generator.format.java.utils.JUtils.getHazelcastClassId;

/**
 * TBD
 */
public class HazelcastPortableProgramFormatter implements BaseProgramFormatter {

    public static final String FACTORY_ID = &quot;FACTORY_ID&quot;;

    private static final String FACTORY_IMPL = &quot;PortableFactoryImpl&quot;;
    private static final String PORTABLE_VERSION = &quot;portableVersion&quot;;
    private static final String CONFIG = &quot;config&quot;;
    private static final String INSTANCE = &quot;instance&quot;;

    private final JHelper             helper;
    private final IndentedPrintWriter writer;
    private final GeneratorOptions    generatorOptions;
    private final JavaOptions         javaOptions;

    public HazelcastPortableProgramFormatter(IndentedPrintWriter writer,
                                             JHelper helper,
                                             GeneratorOptions generatorOptions,
<span class="fc" id="L57">                                             JavaOptions javaOptions) {</span>
<span class="fc" id="L58">        this.writer = writer;</span>
<span class="fc" id="L59">        this.helper = helper;</span>
<span class="fc" id="L60">        this.generatorOptions = generatorOptions;</span>
<span class="fc" id="L61">        this.javaOptions = javaOptions;</span>
<span class="fc" id="L62">    }</span>

    @Override
    public void appendProgramClass(CProgram document) throws GeneratorException {
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">        if (document.getDocumentation() != null) {</span>
<span class="nc" id="L67">            new BlockCommentBuilder(writer).comment(document.getDocumentation())</span>
<span class="nc" id="L68">                                           .finish();</span>
        }

<span class="pc bpc" id="L71" title="1 of 2 branches missed.">        if (javaOptions.generated_annotation_version) {</span>
<span class="fc" id="L72">            writer.formatln(&quot;@%s(\&quot;%s %s\&quot;)&quot;,</span>
<span class="fc" id="L73">                            Generated.class.getName(),</span>
                            generatorOptions.generator_program_name,
                            generatorOptions.program_version);
        } else {
<span class="nc" id="L77">            writer.formatln(&quot;@%s(\&quot;%s\&quot;)&quot;,</span>
<span class="nc" id="L78">                            Generated.class.getName(),</span>
                            generatorOptions.generator_program_name);
        }

<span class="fc" id="L82">        writer.formatln(&quot;public class %s {&quot;, helper.getHazelcastFactoryClassName(document))</span>
<span class="fc" id="L83">              .begin()</span>
<span class="fc" id="L84">              .newline();</span>

<span class="fc" id="L86">        Optional&lt;CConst&gt; factoryID = document.getConstants()</span>
<span class="fc" id="L87">                                             .stream()</span>
<span class="fc" id="L88">                                             .filter(t -&gt; t.getName()</span>
<span class="fc" id="L89">                                                           .equals(FACTORY_ID))</span>
<span class="fc" id="L90">                                             .findFirst();</span>

<span class="pc bpc" id="L92" title="1 of 2 branches missed.">        if (!factoryID.isPresent()) {</span>
<span class="nc" id="L93">            throw new GeneratorException(</span>
                    &quot;Need to provide \&quot;const i32 FACTORY_ID = ?\&quot; in the thrift file for &quot; + &quot;hazelcast generation!&quot;);
        } else {
<span class="fc" id="L96">            CConst c = factoryID.get();</span>
<span class="fc" id="L97">            String type = helper.getValueType(c.getDescriptor());</span>
<span class="fc" id="L98">            String name = c.getName();</span>
<span class="fc" id="L99">            writer.formatln(&quot;public static final %s %s = %s.%s;&quot;,</span>
                            type,
                            name,
<span class="fc" id="L102">                            helper.getConstantsClassName(document),</span>
                            name)
<span class="fc" id="L104">                  .newline();</span>
        }

<span class="fc" id="L107">        List&lt;CStructDescriptor&gt; messages = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L109" title="All 2 branches covered.">        for (PDeclaredDescriptor c : document.getDeclaredTypes()) {</span>
            try {
<span class="pc bpc" id="L111" title="1 of 4 branches missed.">                if (PType.MESSAGE == c.getType() &amp;&amp; c instanceof CStructDescriptor) {</span>
<span class="fc" id="L112">                    CStructDescriptor message = (CStructDescriptor) c;</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">                    if (message.hasAnnotation(ThriftAnnotation.JAVA_HAZELCAST_CLASS_ID)) {</span>
<span class="fc" id="L114">                        writer.formatln(&quot;public static final int %s = %s;&quot;,</span>
<span class="fc" id="L115">                                        getHazelcastClassId(message.getName()),</span>
<span class="fc" id="L116">                                        message.getAnnotationValue(ThriftAnnotation.JAVA_HAZELCAST_CLASS_ID));</span>
<span class="fc" id="L117">                        messages.add(message);</span>
                    }
                }
<span class="nc" id="L120">            } catch (Exception e) {</span>
<span class="nc" id="L121">                throw new GeneratorException(e.getMessage());</span>
<span class="fc" id="L122">            }</span>
<span class="fc" id="L123">        }</span>
<span class="fc" id="L124">        writer.newline();</span>

<span class="fc" id="L126">        appendPopulateMethod(messages);</span>

<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        if (messages.isEmpty()) {</span>
<span class="nc" id="L129">            throw new GeneratorException(&quot;No annotations available to generate!&quot;);</span>
        } else {
<span class="fc" id="L131">            writer.formatln(&quot;private static class %s implements %s {&quot;, FACTORY_IMPL, PortableFactory.class.getName())</span>
<span class="fc" id="L132">                  .begin()</span>
<span class="fc" id="L133">                  .newline();</span>
<span class="fc" id="L134">            appendCreateMethod(messages);</span>
<span class="fc" id="L135">            appendGetDefinitions(messages);</span>
<span class="fc" id="L136">            writer.end()</span>
<span class="fc" id="L137">                  .appendln(&quot;}&quot;);</span>
        }

<span class="fc" id="L140">        writer.end()</span>
<span class="fc" id="L141">              .appendln(&quot;}&quot;)</span>
<span class="fc" id="L142">              .newline();</span>
<span class="fc" id="L143">    }</span>

    /**
     * Method to write the create method from implemented PortableFactory
     *
     * @param messages List with CStructDescriptor.
     * &lt;pre&gt;
     * {@code
     *  @Override
     *  public com.hazelcast.nio.serialization.Portable create(int classId) {
     *      switch(classId) {
     *          ...
     *          default: {
     *              return null;
     *          }
     *      }
     *  }
     * }
     * &lt;/pre&gt;
     */
    private void appendCreateMethod(List&lt;CStructDescriptor&gt; messages) {
<span class="fc" id="L164">        writer.appendln(&quot;@Override&quot;)</span>
<span class="fc" id="L165">              .formatln(&quot;public %s create(int classId) {&quot;, Portable.class.getName())</span>
<span class="fc" id="L166">              .begin()</span>
<span class="fc" id="L167">              .appendln(&quot;switch(classId) {&quot;)</span>
<span class="fc" id="L168">              .begin();</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        for (CStructDescriptor message : messages) {</span>
<span class="fc" id="L170">            writer.formatln(&quot;case %s: {&quot;, getHazelcastClassId(message.getName()))</span>
<span class="fc" id="L171">                  .begin()</span>
<span class="fc" id="L172">                  .formatln(&quot;return new %s.%s();&quot;,</span>
<span class="fc" id="L173">                            message.getName(),</span>
                            HazelcastPortableMessageFormatter.WRAPPER_CLASS_NAME)
<span class="fc" id="L175">                  .end()</span>
<span class="fc" id="L176">                  .appendln(&quot;}&quot;);</span>
<span class="fc" id="L177">        }</span>
<span class="fc" id="L178">        writer.appendln(&quot;default: {&quot;)</span>
<span class="fc" id="L179">              .begin()</span>
<span class="fc" id="L180">              .appendln(&quot;return null;&quot;)</span>
<span class="fc" id="L181">              .end()</span>
<span class="fc" id="L182">              .appendln(&quot;}&quot;)</span>
<span class="fc" id="L183">              .end();</span>
<span class="fc" id="L184">        writer.appendln(&quot;}&quot;)</span>
<span class="fc" id="L185">              .end()</span>
<span class="fc" id="L186">              .appendln(&quot;}&quot;)</span>
<span class="fc" id="L187">              .newline();</span>
<span class="fc" id="L188">    }</span>

    /**
     * Method to append populate methods for the Hazelcast Config.
     *
     * @param messages List with CStructDescriptor to iterate through.
     * &lt;pre&gt;
     * {@code
     *  public static final com.hazelcast.config.Config populateConfig(com.hazelcast.config.Config config) {
     *      PortableFactoryImpl instance = new PortableFactoryImpl();
     *      config.getSerializationConfig().addPortableFactory(FACTORY_ID, instance);
     *      ...
     *      return config;
     *  }
     * }
     * &lt;/pre&gt;
     */
    private void appendPopulateMethod(List&lt;CStructDescriptor&gt; messages) {
<span class="fc" id="L206">        writer.formatln(&quot;public static final %s populateConfig(%s %s, int %s) {&quot;,</span>
<span class="fc" id="L207">                        Config.class.getName(),</span>
<span class="fc" id="L208">                        Config.class.getName(),</span>
                        CONFIG,
                        PORTABLE_VERSION)
<span class="fc" id="L211">              .begin()</span>
<span class="fc" id="L212">              .formatln(&quot;%s %s = new %s();&quot;, FACTORY_IMPL, INSTANCE, FACTORY_IMPL)</span>
<span class="fc" id="L213">              .formatln(&quot;%s.getSerializationConfig().addPortableFactory(%s, %s);&quot;, CONFIG, FACTORY_ID, INSTANCE)</span>
<span class="fc" id="L214">              .formatln(&quot;%s.getSerializationConfig().setPortableVersion(%s);&quot;, CONFIG, PORTABLE_VERSION)</span>
<span class="fc" id="L215">              .appendln()</span>
<span class="fc" id="L216">              .formatln(&quot;%s.getSerializationConfig()&quot;, CONFIG)</span>
<span class="fc" id="L217">              .begin()</span>
<span class="fc" id="L218">              .begin();</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        for (CStructDescriptor struct : messages) {</span>
<span class="fc" id="L220">            writer.formatln(&quot;.addClassDefinition(%s.%s(%s))&quot;,</span>
                            INSTANCE,
<span class="fc" id="L222">                            camelCase(&quot;get&quot;, struct.getName() + &quot;Definition&quot;),</span>
                            PORTABLE_VERSION);
<span class="fc" id="L224">        }</span>
<span class="fc" id="L225">        writer.append(&quot;;&quot;)</span>
<span class="fc" id="L226">              .end()</span>
<span class="fc" id="L227">              .end()</span>
<span class="fc" id="L228">              .formatln(&quot;return %s;&quot;, CONFIG)</span>
<span class="fc" id="L229">              .end()</span>
<span class="fc" id="L230">              .appendln(&quot;}&quot;)</span>
<span class="fc" id="L231">              .newline();</span>
<span class="fc" id="L232">    }</span>

    private void appendGetDefinitions(List&lt;CStructDescriptor&gt; messages) {
<span class="fc bfc" id="L235" title="All 2 branches covered.">        for (CStructDescriptor message : messages) {</span>
<span class="fc" id="L236">            appendGetDefinition(new JMessage&lt;&gt;(message, helper));</span>
<span class="fc" id="L237">        }</span>
<span class="fc" id="L238">    }</span>

    private void appendGetDefinition(JMessage&lt;?&gt; message) {
<span class="fc" id="L241">        writer.formatln(&quot;public %s %s(int %s) {&quot;,</span>
<span class="fc" id="L242">                        ClassDefinition.class.getName(),</span>
<span class="fc" id="L243">                        camelCase(&quot;get&quot;,</span>
<span class="fc" id="L244">                                  message.descriptor()</span>
<span class="fc" id="L245">                                         .getName() + &quot;Definition&quot;),</span>
                        PORTABLE_VERSION)
<span class="fc" id="L247">              .begin()</span>
<span class="fc" id="L248">              .formatln(&quot;return new %s(%s, %s, %s)&quot;,</span>
<span class="fc" id="L249">                        ClassDefinitionBuilder.class.getName(),</span>
                        FACTORY_ID,
<span class="fc" id="L251">                        getHazelcastClassId(message.instanceType()),</span>
                        PORTABLE_VERSION)
<span class="fc" id="L253">              .begin()</span>
<span class="fc" id="L254">              .begin();</span>
<span class="fc" id="L255">        writer.formatln(&quot;.addIntArrayField(\&quot;__fields__\&quot;)&quot;);</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">        for (JField field : message.declaredOrderFields()) {</span>
<span class="fc" id="L257">            appendTypeField(field);</span>
<span class="fc" id="L258">        }</span>
<span class="fc" id="L259">        writer.appendln(&quot;.build();&quot;)</span>
<span class="fc" id="L260">              .end()</span>
<span class="fc" id="L261">              .end()</span>
<span class="fc" id="L262">              .end()</span>
<span class="fc" id="L263">              .appendln(&quot;}&quot;)</span>
<span class="fc" id="L264">              .newline();</span>
<span class="fc" id="L265">    }</span>

    private void appendTypeField(JField field) {
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">        if (field.portableRequiresBinarySerialization()) {</span>
<span class="nc" id="L269">            writer.formatln(&quot;.addByteArrayField(\&quot;%s\&quot;)&quot;, field.name());</span>
<span class="nc" id="L270">            return;</span>
        }

<span class="pc bpc" id="L273" title="2 of 12 branches missed.">        switch (field.type()) {</span>
            case BINARY:
<span class="fc" id="L275">                writer.formatln(&quot;.addByteArrayField(\&quot;%s\&quot;)&quot;, field.name());</span>
<span class="fc" id="L276">                break;</span>
            case BYTE:
<span class="fc" id="L278">                writer.formatln(&quot;.addByteField(\&quot;%s\&quot;)&quot;, field.name());</span>
<span class="fc" id="L279">                break;</span>
            case BOOL:
<span class="fc" id="L281">                writer.formatln(&quot;.addBooleanField(\&quot;%s\&quot;)&quot;, field.name());</span>
<span class="fc" id="L282">                break;</span>
            case DOUBLE:
<span class="fc" id="L284">                writer.formatln(&quot;.addDoubleField(\&quot;%s\&quot;)&quot;, field.name());</span>
<span class="fc" id="L285">                break;</span>
            case ENUM:
            case I32:
<span class="fc" id="L288">                writer.formatln(&quot;.addIntField(\&quot;%s\&quot;)&quot;, field.name());</span>
<span class="fc" id="L289">                break;</span>
            case I16:
<span class="fc" id="L291">                writer.formatln(&quot;.addShortField(\&quot;%s\&quot;)&quot;, field.name());</span>
<span class="fc" id="L292">                break;</span>
            case I64:
<span class="fc" id="L294">                writer.formatln(&quot;.addLongField(\&quot;%s\&quot;)&quot;, field.name());</span>
<span class="fc" id="L295">                break;</span>
            case STRING:
<span class="fc" id="L297">                writer.formatln(&quot;.addUTFField(\&quot;%s\&quot;)&quot;, field.name());</span>
<span class="fc" id="L298">                break;</span>
            case LIST:
<span class="fc" id="L300">                final PList pList = field.toPList();</span>
<span class="fc" id="L301">                appendCollectionTypeField(field, pList.itemDescriptor());</span>
<span class="fc" id="L302">                break;</span>
            case SET:
<span class="nc" id="L304">                final PSet pSet = field.toPSet();</span>
<span class="nc" id="L305">                appendCollectionTypeField(field, pSet.itemDescriptor());</span>
<span class="nc" id="L306">                break;</span>
            case MESSAGE:
<span class="fc" id="L308">                writer.formatln(&quot;.addPortableField(\&quot;%s\&quot;, %s(%s))&quot;,</span>
<span class="fc" id="L309">                                field.name(),</span>
<span class="fc" id="L310">                                camelCase(&quot;get&quot;,</span>
<span class="fc" id="L311">                                          field.field()</span>
<span class="fc" id="L312">                                               .getDescriptor()</span>
<span class="fc" id="L313">                                               .getName() + &quot;Definition&quot;),</span>
                                PORTABLE_VERSION);
<span class="fc" id="L315">                break;</span>
            default:
<span class="nc" id="L317">                throw new GeneratorException(&quot;Not implemented appendTypeField for type: &quot; + field.type() + &quot; in &quot; +</span>
<span class="nc" id="L318">                                             this.getClass()</span>
<span class="nc" id="L319">                                                 .getSimpleName());</span>
        }
<span class="fc" id="L321">    }</span>

    /**
     * Append a specific list type field to the definition.
     *
     * @param field JField to append.
     * &lt;pre&gt;
     * {@code
     *  .addShortArrayField(&quot;shortValues&quot;)
     * }
     * &lt;/pre&gt;
     */
    private void appendCollectionTypeField(JField field, PDescriptor descriptor) {
<span class="pc bpc" id="L334" title="1 of 9 branches missed.">        switch (descriptor.getType()) {</span>
            case BYTE:
            case BINARY:
<span class="fc" id="L337">                writer.formatln(&quot;.addByteArrayField(\&quot;%s\&quot;)&quot;, field.name());</span>
<span class="fc" id="L338">                break;</span>
            case BOOL:
<span class="fc" id="L340">                writer.formatln(&quot;.addBooleanArrayField(\&quot;%s\&quot;)&quot;, field.name());</span>
<span class="fc" id="L341">                break;</span>
            case DOUBLE:
<span class="fc" id="L343">                writer.formatln(&quot;.addDoubleArrayField(\&quot;%s\&quot;)&quot;, field.name());</span>
<span class="fc" id="L344">                break;</span>
            case I16:
<span class="fc" id="L346">                writer.formatln(&quot;.addShortArrayField(\&quot;%s\&quot;)&quot;, field.name());</span>
<span class="fc" id="L347">                break;</span>
            case I32:
            case ENUM:
<span class="fc" id="L350">                writer.formatln(&quot;.addIntArrayField(\&quot;%s\&quot;)&quot;, field.name());</span>
<span class="fc" id="L351">                break;</span>
            case I64:
<span class="fc" id="L353">                writer.formatln(&quot;.addLongArrayField(\&quot;%s\&quot;)&quot;, field.name());</span>
<span class="fc" id="L354">                break;</span>
            case STRING:
<span class="fc" id="L356">                writer.formatln(&quot;.addUTFArrayField(\&quot;%s\&quot;)&quot;, field.name());</span>
<span class="fc" id="L357">                break;</span>
            case MESSAGE:
<span class="fc" id="L359">                writer.formatln(&quot;.addPortableArrayField(\&quot;%s\&quot;, %s(%s))&quot;,</span>
<span class="fc" id="L360">                                field.name(),</span>
<span class="fc" id="L361">                                camelCase(&quot;get&quot;, descriptor.getName() + &quot;Definition&quot;),</span>
                                PORTABLE_VERSION);
<span class="fc" id="L363">                break;</span>
            default:
<span class="nc" id="L365">                throw new GeneratorException(</span>
<span class="nc" id="L366">                        &quot;Not implemented appendCollectionTypeField for list with type: &quot; + descriptor.getType() + &quot; in &quot; +</span>
<span class="nc" id="L367">                        this.getClass()</span>
<span class="nc" id="L368">                            .getSimpleName());</span>
        }
<span class="fc" id="L370">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>