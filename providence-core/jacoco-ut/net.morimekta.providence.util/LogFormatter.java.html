<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LogFormatter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Providence Core</a> &gt; <a href="index.source.html" class="el_package">net.morimekta.providence.util</a> &gt; <span class="el_source">LogFormatter.java</span></div><h1>LogFormatter.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015-2016 Providence Authors
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package net.morimekta.providence.util;

import net.morimekta.providence.PEnumValue;
import net.morimekta.providence.PMessage;
import net.morimekta.providence.PType;
import net.morimekta.providence.PUnion;
import net.morimekta.providence.descriptor.PContainer;
import net.morimekta.providence.descriptor.PDescriptor;
import net.morimekta.providence.descriptor.PField;
import net.morimekta.providence.descriptor.PMap;
import net.morimekta.providence.descriptor.PMessageDescriptor;
import net.morimekta.providence.descriptor.PPrimitive;
import net.morimekta.providence.util.pretty.Token;
import net.morimekta.util.Binary;
import net.morimekta.util.Strings;
import net.morimekta.util.io.IndentedPrintWriter;

import com.google.common.collect.ImmutableList;

import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.text.DecimalFormat;
import java.util.Collection;
import java.util.List;
import java.util.Map;

/**
 * LogFormatter is a formatter (one-way serialization) similar to the PrettySerializer,
 * except it supports adding FieldHandlers to modify in.
 *
 * Note that the LogFormatter is &lt;b&gt;not&lt;/b&gt; a serializer, as there is no guarantee the
 * result can be parsed back at all.
 */
public class LogFormatter {
    /**
     * Handler for a single field in a message. If it returns true, will consume the field.
     * The visible (printed) value must be written to the IndentedPrintWriter.
     */
    @FunctionalInterface
    public interface FieldHandler {
        boolean appendFieldValue(IndentedPrintWriter writer, PField field, Object value);
    }

    private final static String INDENT   = &quot;  &quot;;
    private final static String SPACE    = &quot; &quot;;
    private final static String NEWLINE  = &quot;\n&quot;;
    private final static String LIST_SEP = &quot;,&quot;;

    private final String             indent;
    private final String             space;
    private final String             newline;
    private final String             entrySep;
    private final List&lt;FieldHandler&gt; fieldHandlers;

    /**
     * Create a log formatter with compact format.
     *
     * @param fieldHandlers Field handlers to specify formatted values of specific fields.
     */
    public LogFormatter(FieldHandler... fieldHandlers) {
<span class="nc" id="L82">        this(false, ImmutableList.copyOf(fieldHandlers));</span>
<span class="nc" id="L83">    }</span>

    /**
     * Create a log formatter.
     *
     * @param pretty If true will add lines, line indentation and extra spaces.
     * @param fieldHandlers Field handlers to specify formatted values of specific fields.
     */
    public LogFormatter(boolean pretty, FieldHandler... fieldHandlers) {
<span class="fc" id="L92">        this(pretty, ImmutableList.copyOf(fieldHandlers));</span>
<span class="fc" id="L93">    }</span>

    /**
     * Create a log formatter.
     *
     * @param pretty If true will add lines, line indentation and extra spaces.
     * @param fieldHandlers Field handlers to specify formatted values of specific fields.
     */
<span class="fc" id="L101">    public LogFormatter(boolean pretty, Collection&lt;FieldHandler&gt; fieldHandlers) {</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">        this.indent = pretty ? INDENT : &quot;&quot;;</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">        this.space = pretty ? SPACE : &quot;&quot;;</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">        this.newline = pretty ? NEWLINE : &quot;&quot;;</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        this.entrySep = pretty ? &quot;&quot; : LIST_SEP;</span>
<span class="fc" id="L106">        this.fieldHandlers = ImmutableList.copyOf(fieldHandlers);</span>
<span class="fc" id="L107">    }</span>

    /**
     * Format message and write to the output stream.
     *
     * @param out The output stream to write to.
     * @param message The message to be written.
     * @param &lt;Message&gt; The message type.
     * @param &lt;Field&gt; The field type.
     */
    public &lt;Message extends PMessage&lt;Message, Field&gt;, Field extends PField&gt;
    void formatTo(OutputStream out, Message message) {
<span class="fc" id="L119">        IndentedPrintWriter builder = new IndentedPrintWriter(out, indent, newline);</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">        if (message == null) {</span>
<span class="fc" id="L121">            builder.append(null);</span>
        } else {
<span class="fc" id="L123">            builder.append(message.descriptor().getQualifiedName())</span>
<span class="fc" id="L124">                   .append(space);</span>
<span class="fc" id="L125">            appendMessage(builder, message);</span>
        }
<span class="fc" id="L127">        builder.flush();</span>
<span class="fc" id="L128">    }</span>

    /**
     * Format message to a string.
     *
     * @param message The message to be written.
     * @param &lt;Message&gt; The message type.
     * @param &lt;Field&gt; The field type.
     * @return The formatted message.
     */
    public &lt;Message extends PMessage&lt;Message, Field&gt;, Field extends PField&gt;
    String format(Message message) {
<span class="fc" id="L140">        ByteArrayOutputStream out = new ByteArrayOutputStream();</span>
<span class="fc" id="L141">        formatTo(out, message);</span>
<span class="fc" id="L142">        return new String(out.toByteArray(), StandardCharsets.UTF_8);</span>
    }

    private void appendMessage(IndentedPrintWriter writer, PMessage&lt;?,?&gt; message) {
<span class="fc" id="L146">        PMessageDescriptor&lt;?, ?&gt; type = message.descriptor();</span>

<span class="fc" id="L148">        writer.append(Token.kMessageStart)</span>
<span class="fc" id="L149">              .begin();</span>

<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if (message instanceof PUnion) {</span>
<span class="nc" id="L152">            PField field = ((PUnion) message).unionField();</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">            if (field != null) {</span>
<span class="nc" id="L154">                Object o = message.get(field.getKey());</span>

<span class="nc" id="L156">                writer.appendln()</span>
<span class="nc" id="L157">                      .append(field.getName())</span>
<span class="nc" id="L158">                      .append(space)</span>
<span class="nc" id="L159">                      .append(Token.kFieldValueSep)</span>
<span class="nc" id="L160">                      .append(space);</span>
<span class="nc" id="L161">                appendFieldValue(writer, field, o);</span>
            }
<span class="nc" id="L163">        } else {</span>
<span class="fc" id="L164">            boolean first = true;</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">            for (PField field : type.getFields()) {</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">                if (message.has(field.getKey())) {</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">                    if (first) {</span>
<span class="fc" id="L168">                        first = false;</span>
                    } else {
<span class="fc" id="L170">                        writer.append(entrySep);</span>
                    }
<span class="fc" id="L172">                    Object o = message.get(field.getKey());</span>

<span class="fc" id="L174">                    writer.appendln()</span>
<span class="fc" id="L175">                          .append(field.getName())</span>
<span class="fc" id="L176">                          .append(space)</span>
<span class="fc" id="L177">                          .append(Token.kFieldValueSep)</span>
<span class="fc" id="L178">                          .append(space);</span>

<span class="fc" id="L180">                    appendFieldValue(writer, field, o);</span>
                }
            }
        }

<span class="fc" id="L185">        writer.end()</span>
<span class="fc" id="L186">              .appendln(Token.kMessageEnd);</span>
<span class="fc" id="L187">    }</span>

    private void appendFieldValue(IndentedPrintWriter writer, PField field, Object value) {
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        if (field.getType() != PType.MESSAGE) {</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            for (FieldHandler handler : fieldHandlers) {</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">                if (handler.appendFieldValue(writer, field, value)) {</span>
<span class="fc" id="L193">                    return;</span>
                }
<span class="fc" id="L195">            }</span>
        }
<span class="fc" id="L197">        appendTypedValue(writer, field.getDescriptor(), value);</span>
<span class="fc" id="L198">    }</span>

    private void appendTypedValue(IndentedPrintWriter writer, PDescriptor descriptor, Object o) {
<span class="pc bpc" id="L201" title="4 of 5 branches missed.">        switch (descriptor.getType()) {</span>
            case LIST:
            case SET: {
<span class="nc" id="L204">                PContainer&lt;?&gt; containerType = (PContainer&lt;?&gt;) descriptor;</span>
<span class="nc" id="L205">                PDescriptor itemType = containerType.itemDescriptor();</span>
<span class="nc" id="L206">                Collection&lt;?&gt; collection = (Collection&lt;?&gt;) o;</span>

<span class="nc" id="L208">                PPrimitive primitive = PPrimitive.findByName(itemType.getName());</span>
<span class="nc bnc" id="L209" title="All 6 branches missed.">                if (primitive != null &amp;&amp;</span>
                    primitive != PPrimitive.STRING &amp;&amp;
                    primitive != PPrimitive.BINARY &amp;&amp;
<span class="nc bnc" id="L212" title="All 2 branches missed.">                    collection.size() &lt;= 10) {</span>
                    // special case if we have simple primitives (numbers and bools) in a &quot;short&quot; list,
                    // print in one single line.
<span class="nc" id="L215">                    writer.append(Token.kListStart);</span>

<span class="nc" id="L217">                    boolean first = true;</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">                    for (Object i : collection) {</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">                        if (first) {</span>
<span class="nc" id="L220">                            first = false;</span>
                        } else {
                            // Lists are always comma-delimited
<span class="nc" id="L223">                            writer.append(Token.kLineSep1)</span>
<span class="nc" id="L224">                                  .append(space);</span>
                        }
<span class="nc" id="L226">                        appendTypedValue(writer, containerType.itemDescriptor(), i);</span>
<span class="nc" id="L227">                    }</span>
<span class="nc" id="L228">                    writer.append(Token.kListEnd);</span>
<span class="nc" id="L229">                } else {</span>
<span class="nc" id="L230">                    writer.append(Token.kListStart)</span>
<span class="nc" id="L231">                          .begin();</span>

<span class="nc" id="L233">                    boolean first = true;</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                    for (Object i : collection) {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">                        if (first) {</span>
<span class="nc" id="L236">                            first = false;</span>
                        } else {
                            // Lists are always comma-delimited
<span class="nc" id="L239">                            writer.append(Token.kLineSep1);</span>
                        }
<span class="nc" id="L241">                        writer.appendln();</span>
<span class="nc" id="L242">                        appendTypedValue(writer, containerType.itemDescriptor(), i);</span>
<span class="nc" id="L243">                    }</span>

<span class="nc" id="L245">                    writer.end()</span>
<span class="nc" id="L246">                          .appendln(Token.kListEnd);</span>
                }
<span class="nc" id="L248">                break;</span>
            }
            case MAP: {
<span class="nc" id="L251">                PMap&lt;?, ?&gt; mapType = (PMap&lt;?, ?&gt;) descriptor;</span>

<span class="nc" id="L253">                Map&lt;?, ?&gt; map = (Map&lt;?, ?&gt;) o;</span>

<span class="nc" id="L255">                writer.append(Token.kMessageStart)</span>
<span class="nc" id="L256">                      .begin();</span>

<span class="nc" id="L258">                boolean first = true;</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">                for (Map.Entry&lt;?, ?&gt; entry : map.entrySet()) {</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">                    if (first) {</span>
<span class="nc" id="L261">                        first = false;</span>
                    } else {
<span class="nc" id="L263">                        writer.append(entrySep);</span>
                    }
<span class="nc" id="L265">                    writer.appendln();</span>
<span class="nc" id="L266">                    appendTypedValue(writer, mapType.keyDescriptor(), entry.getKey());</span>
<span class="nc" id="L267">                    writer.append(Token.kKeyValueSep)</span>
<span class="nc" id="L268">                          .append(space);</span>
<span class="nc" id="L269">                    appendTypedValue(writer, mapType.itemDescriptor(), entry.getValue());</span>
<span class="nc" id="L270">                }</span>

<span class="nc" id="L272">                writer.end()</span>
<span class="nc" id="L273">                      .appendln(Token.kMessageEnd);</span>
<span class="nc" id="L274">                break;</span>
            }
            case VOID:
<span class="nc" id="L277">                writer.print(true);</span>
<span class="nc" id="L278">                break;</span>
            case MESSAGE:
<span class="nc" id="L280">                PMessage&lt;?,?&gt; message = (PMessage&lt;?, ?&gt;) o;</span>
<span class="nc" id="L281">                appendMessage(writer, message);</span>
<span class="nc" id="L282">                break;</span>
            default:
<span class="fc" id="L284">                appendPrimitive(writer, o);</span>
                break;
        }
<span class="fc" id="L287">    }</span>

    private void appendPrimitive(IndentedPrintWriter writer, Object o) {
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">        if (o instanceof PEnumValue) {</span>
<span class="nc" id="L291">            writer.print(((PEnumValue) o).asString());</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">        } else if (o instanceof CharSequence) {</span>
<span class="fc" id="L293">            writer.print(Token.kLiteralDoubleQuote);</span>
<span class="fc" id="L294">            writer.print(Strings.escape((CharSequence) o));</span>
<span class="fc" id="L295">            writer.print(Token.kLiteralDoubleQuote);</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        } else if (o instanceof Binary) {</span>
<span class="nc" id="L297">            Binary b = (Binary) o;</span>
<span class="nc" id="L298">            writer.append(Token.B64)</span>
<span class="nc" id="L299">                  .append(Token.kMethodStart)</span>
<span class="nc" id="L300">                  .append(b.toBase64())</span>
<span class="nc" id="L301">                  .append(Token.kMethodEnd);</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">        } else if (o instanceof Boolean) {</span>
<span class="nc" id="L303">            writer.print(((Boolean) o).booleanValue());</span>
<span class="nc bnc" id="L304" title="All 8 branches missed.">        } else if (o instanceof Byte || o instanceof Short || o instanceof Integer || o instanceof Long) {</span>
<span class="nc" id="L305">            writer.print(Strings.escape(o.toString()));</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        } else if (o instanceof Double) {</span>
<span class="nc" id="L307">            Double d = (Double) o;</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">            if (d == ((double) d.longValue())) {</span>
                // actually an integer or long value.
<span class="nc" id="L310">                writer.print(d.longValue());</span>
<span class="nc bnc" id="L311" title="All 4 branches missed.">            } else if (d &gt; ((10 &lt;&lt; 9) - 1) || (1 / d) &gt; (10 &lt;&lt; 6)) {</span>
                // Scientific notation should be used, this enforces a decimal
                // length that is not too overwhelming.
<span class="nc" id="L314">                writer.print((new DecimalFormat(&quot;0.#########E0&quot;)).format(d.doubleValue()));</span>
            } else {
<span class="nc" id="L316">                writer.print(d.doubleValue());</span>
            }
<span class="nc" id="L318">        } else {</span>
<span class="nc" id="L319">            throw new IllegalArgumentException(&quot;Unknown primitive type class &quot; + o.getClass()</span>
<span class="nc" id="L320">                                                                                  .getSimpleName());</span>
        }
<span class="fc" id="L322">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>