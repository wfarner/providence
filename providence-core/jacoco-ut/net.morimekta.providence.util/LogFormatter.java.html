<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LogFormatter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Providence Core</a> &gt; <a href="index.source.html" class="el_package">net.morimekta.providence.util</a> &gt; <span class="el_source">LogFormatter.java</span></div><h1>LogFormatter.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015-2016 Providence Authors
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package net.morimekta.providence.util;

import net.morimekta.providence.PEnumValue;
import net.morimekta.providence.PMessage;
import net.morimekta.providence.PType;
import net.morimekta.providence.PUnion;
import net.morimekta.providence.descriptor.PContainer;
import net.morimekta.providence.descriptor.PDescriptor;
import net.morimekta.providence.descriptor.PField;
import net.morimekta.providence.descriptor.PMap;
import net.morimekta.providence.descriptor.PMessageDescriptor;
import net.morimekta.providence.descriptor.PPrimitive;
import net.morimekta.providence.serializer.pretty.Token;
import net.morimekta.util.Binary;
import net.morimekta.util.Strings;
import net.morimekta.util.io.IndentedPrintWriter;

import com.google.common.collect.ImmutableList;

import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.List;
import java.util.Map;

/**
 * LogFormatter is a formatter (one-way serialization) similar to the PrettySerializer,
 * except it supports adding FieldHandlers to modify in.
 *
 * Note that the LogFormatter is &lt;b&gt;not&lt;/b&gt; a serializer, as there is no guarantee the
 * result can be parsed back at all.
 */
public class LogFormatter {
    /**
     * Handler for a single field in a message. If it returns true, will consume the field.
     * The visible (printed) value must be written to the IndentedPrintWriter.
     */
    @FunctionalInterface
    public interface FieldHandler {
        boolean appendFieldValue(IndentedPrintWriter writer, PField field, Object value);
    }

    private final static String INDENT   = &quot;  &quot;;
    private final static String SPACE    = &quot; &quot;;
    private final static String NEWLINE  = &quot;\n&quot;;
    private final static String LIST_SEP = &quot;,&quot;;

    private final String             indent;
    private final String             space;
    private final String             newline;
    private final String             entrySep;
    private final List&lt;FieldHandler&gt; fieldHandlers;

    /**
     * Create a log formatter with compact format.
     *
     * @param fieldHandlers Field handlers to specify formatted values of specific fields.
     */
    public LogFormatter(FieldHandler... fieldHandlers) {
<span class="fc" id="L81">        this(false, ImmutableList.copyOf(fieldHandlers));</span>
<span class="fc" id="L82">    }</span>

    /**
     * Create a log formatter.
     *
     * @param pretty If true will add lines, line indentation and extra spaces.
     * @param fieldHandlers Field handlers to specify formatted values of specific fields.
     */
    public LogFormatter(boolean pretty, FieldHandler... fieldHandlers) {
<span class="fc" id="L91">        this(pretty, ImmutableList.copyOf(fieldHandlers));</span>
<span class="fc" id="L92">    }</span>

    /**
     * Create a log formatter.
     *
     * @param pretty If true will add lines, line indentation and extra spaces.
     * @param fieldHandlers Field handlers to specify formatted values of specific fields.
     */
<span class="fc" id="L100">    public LogFormatter(boolean pretty, Collection&lt;FieldHandler&gt; fieldHandlers) {</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">        this.indent = pretty ? INDENT : &quot;&quot;;</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">        this.space = pretty ? SPACE : &quot;&quot;;</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">        this.newline = pretty ? NEWLINE : &quot;&quot;;</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">        this.entrySep = pretty ? &quot;&quot; : LIST_SEP;</span>
<span class="fc" id="L105">        this.fieldHandlers = ImmutableList.copyOf(fieldHandlers);</span>
<span class="fc" id="L106">    }</span>

    /**
     * Format message and write to the output stream.
     *
     * @param out The output stream to write to.
     * @param message The message to be written.
     * @param &lt;Message&gt; The message type.
     * @param &lt;Field&gt; The field type.
     */
    public &lt;Message extends PMessage&lt;Message, Field&gt;, Field extends PField&gt;
    void formatTo(OutputStream out, Message message) {
<span class="fc" id="L118">        IndentedPrintWriter builder = new IndentedPrintWriter(out, indent, newline);</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">        if (message == null) {</span>
<span class="fc" id="L120">            builder.append(null);</span>
        } else {
<span class="fc" id="L122">            builder.append(message.descriptor().getQualifiedName())</span>
<span class="fc" id="L123">                   .append(space);</span>
<span class="fc" id="L124">            appendMessage(builder, message);</span>
        }
<span class="fc" id="L126">        builder.flush();</span>
<span class="fc" id="L127">    }</span>

    /**
     * Format message to a string.
     *
     * @param message The message to be written.
     * @param &lt;Message&gt; The message type.
     * @param &lt;Field&gt; The field type.
     * @return The formatted message.
     */
    public &lt;Message extends PMessage&lt;Message, Field&gt;, Field extends PField&gt;
    String format(Message message) {
<span class="fc" id="L139">        ByteArrayOutputStream out = new ByteArrayOutputStream();</span>
<span class="fc" id="L140">        formatTo(out, message);</span>
<span class="fc" id="L141">        return new String(out.toByteArray(), StandardCharsets.UTF_8);</span>
    }

    private void appendMessage(IndentedPrintWriter writer, PMessage&lt;?,?&gt; message) {
<span class="fc" id="L145">        PMessageDescriptor&lt;?, ?&gt; type = message.descriptor();</span>

<span class="fc" id="L147">        writer.append(Token.kMessageStart)</span>
<span class="fc" id="L148">              .begin();</span>

<span class="fc bfc" id="L150" title="All 2 branches covered.">        if (message instanceof PUnion) {</span>
<span class="fc" id="L151">            PField field = ((PUnion) message).unionField();</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">            if (field != null) {</span>
<span class="fc" id="L153">                Object o = message.get(field.getId());</span>

<span class="fc" id="L155">                writer.appendln()</span>
<span class="fc" id="L156">                      .append(field.getName())</span>
<span class="fc" id="L157">                      .append(space)</span>
<span class="fc" id="L158">                      .append(Token.kFieldValueSep)</span>
<span class="fc" id="L159">                      .append(space);</span>
<span class="fc" id="L160">                appendFieldValue(writer, field, o);</span>
            }
<span class="fc" id="L162">        } else {</span>
<span class="fc" id="L163">            boolean first = true;</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">            for (PField field : type.getFields()) {</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">                if (message.has(field.getId())) {</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">                    if (first) {</span>
<span class="fc" id="L167">                        first = false;</span>
                    } else {
<span class="fc" id="L169">                        writer.append(entrySep);</span>
                    }
<span class="fc" id="L171">                    Object o = message.get(field.getId());</span>

<span class="fc" id="L173">                    writer.appendln()</span>
<span class="fc" id="L174">                          .append(field.getName())</span>
<span class="fc" id="L175">                          .append(space)</span>
<span class="fc" id="L176">                          .append(Token.kFieldValueSep)</span>
<span class="fc" id="L177">                          .append(space);</span>

<span class="fc" id="L179">                    appendFieldValue(writer, field, o);</span>
                }
            }
        }

<span class="fc" id="L184">        writer.end()</span>
<span class="fc" id="L185">              .appendln(Token.kMessageEnd);</span>
<span class="fc" id="L186">    }</span>

    private void appendFieldValue(IndentedPrintWriter writer, PField field, Object value) {
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (field.getType() != PType.MESSAGE) {</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">            for (FieldHandler handler : fieldHandlers) {</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">                if (handler.appendFieldValue(writer, field, value)) {</span>
<span class="fc" id="L192">                    return;</span>
                }
<span class="fc" id="L194">            }</span>
        }
<span class="fc" id="L196">        appendTypedValue(writer, field.getDescriptor(), value);</span>
<span class="fc" id="L197">    }</span>

    private void appendTypedValue(IndentedPrintWriter writer, PDescriptor descriptor, Object o) {
<span class="pc bpc" id="L200" title="1 of 5 branches missed.">        switch (descriptor.getType()) {</span>
            case LIST:
            case SET: {
<span class="fc" id="L203">                PContainer&lt;?&gt; containerType = (PContainer&lt;?&gt;) descriptor;</span>
<span class="fc" id="L204">                PDescriptor itemType = containerType.itemDescriptor();</span>
<span class="fc" id="L205">                Collection&lt;?&gt; collection = (Collection&lt;?&gt;) o;</span>

<span class="fc" id="L207">                PPrimitive primitive = PPrimitive.findByName(itemType.getName());</span>
<span class="fc bfc" id="L208" title="All 6 branches covered.">                if (primitive != null &amp;&amp;</span>
                    primitive != PPrimitive.STRING &amp;&amp;
                    primitive != PPrimitive.BINARY &amp;&amp;
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">                    collection.size() &lt;= 10) {</span>
                    // special case if we have simple primitives (numbers and bools) in a &quot;short&quot; list,
                    // print in one single line.
<span class="fc" id="L214">                    writer.append(Token.kListStart);</span>

<span class="fc" id="L216">                    boolean first = true;</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">                    for (Object i : collection) {</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">                        if (first) {</span>
<span class="fc" id="L219">                            first = false;</span>
                        } else {
                            // Lists are always comma-delimited
<span class="fc" id="L222">                            writer.append(Token.kLineSep1)</span>
<span class="fc" id="L223">                                  .append(space);</span>
                        }
<span class="fc" id="L225">                        appendTypedValue(writer, containerType.itemDescriptor(), i);</span>
<span class="fc" id="L226">                    }</span>
<span class="fc" id="L227">                    writer.append(Token.kListEnd);</span>
<span class="fc" id="L228">                } else {</span>
<span class="fc" id="L229">                    writer.append(Token.kListStart)</span>
<span class="fc" id="L230">                          .begin();</span>

<span class="fc" id="L232">                    boolean first = true;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">                    for (Object i : collection) {</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">                        if (first) {</span>
<span class="fc" id="L235">                            first = false;</span>
                        } else {
                            // Lists are always comma-delimited
<span class="fc" id="L238">                            writer.append(Token.kLineSep1);</span>
                        }
<span class="fc" id="L240">                        writer.appendln();</span>
<span class="fc" id="L241">                        appendTypedValue(writer, containerType.itemDescriptor(), i);</span>
<span class="fc" id="L242">                    }</span>

<span class="fc" id="L244">                    writer.end()</span>
<span class="fc" id="L245">                          .appendln(Token.kListEnd);</span>
                }
<span class="fc" id="L247">                break;</span>
            }
            case MAP: {
<span class="fc" id="L250">                PMap&lt;?, ?&gt; mapType = (PMap&lt;?, ?&gt;) descriptor;</span>

<span class="fc" id="L252">                Map&lt;?, ?&gt; map = (Map&lt;?, ?&gt;) o;</span>

<span class="fc" id="L254">                writer.append(Token.kMessageStart)</span>
<span class="fc" id="L255">                      .begin();</span>

<span class="fc" id="L257">                boolean first = true;</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">                for (Map.Entry&lt;?, ?&gt; entry : map.entrySet()) {</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">                    if (first) {</span>
<span class="fc" id="L260">                        first = false;</span>
                    } else {
<span class="fc" id="L262">                        writer.append(entrySep);</span>
                    }
<span class="fc" id="L264">                    writer.appendln();</span>
<span class="fc" id="L265">                    appendTypedValue(writer, mapType.keyDescriptor(), entry.getKey());</span>
<span class="fc" id="L266">                    writer.append(Token.kKeyValueSep)</span>
<span class="fc" id="L267">                          .append(space);</span>
<span class="fc" id="L268">                    appendTypedValue(writer, mapType.itemDescriptor(), entry.getValue());</span>
<span class="fc" id="L269">                }</span>

<span class="fc" id="L271">                writer.end()</span>
<span class="fc" id="L272">                      .appendln(Token.kMessageEnd);</span>
<span class="fc" id="L273">                break;</span>
            }
            case VOID:
<span class="nc" id="L276">                writer.print(true);</span>
<span class="nc" id="L277">                break;</span>
            case MESSAGE:
<span class="fc" id="L279">                PMessage&lt;?,?&gt; message = (PMessage&lt;?, ?&gt;) o;</span>
<span class="fc" id="L280">                appendMessage(writer, message);</span>
<span class="fc" id="L281">                break;</span>
            default:
<span class="fc" id="L283">                appendPrimitive(writer, o);</span>
                break;
        }
<span class="fc" id="L286">    }</span>

    private void appendPrimitive(IndentedPrintWriter writer, Object o) {
<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (o instanceof PEnumValue) {</span>
<span class="fc" id="L290">            writer.print(((PEnumValue) o).asString());</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">        } else if (o instanceof CharSequence) {</span>
<span class="fc" id="L292">            writer.print(Token.kLiteralDoubleQuote);</span>
<span class="fc" id="L293">            writer.print(Strings.escape((CharSequence) o));</span>
<span class="fc" id="L294">            writer.print(Token.kLiteralDoubleQuote);</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">        } else if (o instanceof Binary) {</span>
<span class="fc" id="L296">            Binary b = (Binary) o;</span>
<span class="fc" id="L297">            writer.append(Token.B64)</span>
<span class="fc" id="L298">                  .append(Token.kParamsStart)</span>
<span class="fc" id="L299">                  .append(b.toBase64())</span>
<span class="fc" id="L300">                  .append(Token.kParamsEnd);</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        } else if (o instanceof Boolean) {</span>
<span class="fc" id="L302">            writer.print(((Boolean) o).booleanValue());</span>
<span class="fc bfc" id="L303" title="All 8 branches covered.">        } else if (o instanceof Byte || o instanceof Short || o instanceof Integer || o instanceof Long) {</span>
<span class="fc" id="L304">            writer.print(o.toString());</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">        } else if (o instanceof Double) {</span>
<span class="fc" id="L306">            Double d = (Double) o;</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">            if (d.equals(((double) d.longValue()))) {</span>
                // actually an integer or long value.
<span class="nc" id="L309">                writer.print(d.longValue());</span>
            } else {
<span class="fc" id="L311">                writer.print(d.doubleValue());</span>
            }
<span class="fc" id="L313">        } else {</span>
<span class="nc" id="L314">            throw new IllegalArgumentException(&quot;Unknown primitive type class &quot; + o.getClass()</span>
<span class="nc" id="L315">                                                                                  .getSimpleName());</span>
        }
<span class="fc" id="L317">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>