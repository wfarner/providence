<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Tokenizer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Providence Utils : Reflection</a> &gt; <a href="index.source.html" class="el_package">net.morimekta.providence.reflect.parser.internal</a> &gt; <span class="el_source">Tokenizer.java</span></div><h1>Tokenizer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016 Providence Authors
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package net.morimekta.providence.reflect.parser.internal;

import net.morimekta.providence.reflect.parser.ParseException;
import net.morimekta.util.Strings;
import net.morimekta.util.io.IOUtils;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * @author Stein Eldar Johnsen
 * @since 24.09.15
 */
public class Tokenizer extends InputStream {
    private final byte[] buffer;
    private int readOffset;

    private int lineNo;
    private int linePos;

    private       Token             nextToken;

<span class="fc" id="L46">    public Tokenizer(InputStream in) throws IOException {</span>
<span class="fc" id="L47">        ByteArrayOutputStream tmp = new ByteArrayOutputStream();</span>
<span class="fc" id="L48">        IOUtils.copy(in, tmp);</span>

<span class="fc" id="L50">        this.buffer = tmp.toByteArray();</span>
<span class="fc" id="L51">        this.readOffset = -1;</span>

<span class="fc" id="L53">        this.lineNo = 1;</span>
<span class="fc" id="L54">        this.linePos = -1;</span>
<span class="fc" id="L55">    }</span>

    @Override
    public int read() {
<span class="fc bfc" id="L59" title="All 2 branches covered.">        if (++readOffset &gt;= buffer.length) {</span>
<span class="fc" id="L60">            readOffset = buffer.length;</span>
<span class="fc" id="L61">            return -1;</span>
        }
<span class="fc" id="L63">        int ret = buffer[readOffset];</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">        if (ret == '\n') {</span>
<span class="fc" id="L65">            ++lineNo;</span>
<span class="fc" id="L66">            linePos = -1;</span>
        } else {
<span class="fc" id="L68">            ++linePos;</span>
        }
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">        return ret &gt; 0 ? ret : 0x100 + ret;</span>
    }

    /**
     * &quot;Unread&quot; the last read byte. Note that line-pos is not usable
     * immediately after reading, until reading again.
     */
    private void unread() {
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">        if (readOffset == buffer.length) {</span>
<span class="nc" id="L79">            --readOffset;</span>
<span class="nc" id="L80">            return;</span>
        }

<span class="fc bfc" id="L83" title="All 2 branches covered.">        if (buffer[readOffset--] == '\n') {</span>
<span class="fc" id="L84">            --lineNo;</span>
        } else {
<span class="fc" id="L86">            --linePos;</span>
        }
<span class="fc" id="L88">    }</span>

    @Nonnull
    public Token expect(String message) throws IOException, ParseException {
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">        if (!hasNext()) {</span>
<span class="nc" id="L93">            throw new ParseException(&quot;Expected %s, but got end of file&quot;, message);</span>
        }
<span class="fc" id="L95">        Token next = nextToken;</span>
<span class="fc" id="L96">        nextToken = null;</span>
<span class="fc" id="L97">        return next;</span>
    }

    @Nonnull
    public Token peek(String message) throws IOException, ParseException {
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">        if (!hasNext()) {</span>
<span class="nc" id="L103">            throw new ParseException(&quot;Expected %s, but got end of file&quot;, message);</span>
        }
<span class="fc" id="L105">        return nextToken;</span>
    }

    @Nullable
    public Token peek() throws IOException, ParseException {
<span class="fc" id="L110">        hasNext();</span>
<span class="fc" id="L111">        return nextToken;</span>
    }

    public char expectSymbol(String message, char... symbols) throws IOException, ParseException {
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        if (!hasNext()) {</span>
<span class="nc" id="L116">            throw new ParseException(&quot;Expected %s, but got end of file&quot;, message);</span>
        } else {
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">            for (char symbol : symbols) {</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">                if (nextToken.isSymbol(symbol)) {</span>
<span class="fc" id="L120">                    nextToken = null;</span>
<span class="fc" id="L121">                    return symbol;</span>
                }
            }

<span class="nc" id="L125">            throw new ParseException(this, nextToken,</span>
                                     &quot;Expected %s, but got '%s'&quot;,
                                     message,
<span class="nc" id="L128">                                     Strings.escape(nextToken.asString()));</span>
        }
    }

    @Nonnull
    public Token expectIdentifier(String message) throws IOException, ParseException {
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (!hasNext()) {</span>
<span class="nc" id="L135">            throw new ParseException(&quot;Expected %s, but got end of file&quot;, message);</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        } else if (nextToken.isIdentifier()) {</span>
<span class="fc" id="L137">            Token next = nextToken;</span>
<span class="fc" id="L138">            nextToken = null;</span>
<span class="fc" id="L139">            return next;</span>
        } else {
<span class="nc" id="L141">            throw new ParseException(this, nextToken,</span>
                                     &quot;Expected %s, but got '%s'&quot;,
                                     message,
<span class="nc" id="L144">                                     Strings.escape(nextToken.asString()));</span>
        }
    }

    @Nonnull
    public Token expectQualifiedIdentifier(String message) throws IOException, ParseException {
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">        if (!hasNext()) {</span>
<span class="nc" id="L151">            throw new ParseException(&quot;Expected %s, but got end of file&quot;, message);</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        } else if (nextToken.isQualifiedIdentifier()) {</span>
<span class="fc" id="L153">            Token next = nextToken;</span>
<span class="fc" id="L154">            nextToken = null;</span>
<span class="fc" id="L155">            return next;</span>
        } else {
<span class="nc" id="L157">            throw new ParseException(this, nextToken,</span>
                                     &quot;Expected %s, but got '%s'&quot;,
                                     message,
<span class="nc" id="L160">                                     Strings.escape(nextToken.asString()));</span>
        }
    }

    @Nonnull
    public Token expectStringLiteral(String message) throws IOException, ParseException {
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        if (!hasNext()) {</span>
<span class="nc" id="L167">            throw new ParseException(&quot;Expected %s, but got end of file&quot;, message);</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        } else if (nextToken.isStringLiteral()) {</span>
<span class="fc" id="L169">            Token next = nextToken;</span>
<span class="fc" id="L170">            nextToken = null;</span>
<span class="fc" id="L171">            return next;</span>
        } else {
<span class="nc" id="L173">            throw new ParseException(this, nextToken,</span>
                                     &quot;Expected %s, but got '%s'&quot;,
                                     message,
<span class="nc" id="L176">                                     Strings.escape(nextToken.asString()));</span>
        }
    }

    @Nonnull
    public Token expectInteger(String message) throws IOException, ParseException {
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">        if (!hasNext()) {</span>
<span class="nc" id="L183">            throw new ParseException(&quot;Expected %s, but got end of file&quot;, message);</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        } else if (nextToken.isInteger()) {</span>
<span class="fc" id="L185">            Token next = nextToken;</span>
<span class="fc" id="L186">            nextToken = null;</span>
<span class="fc" id="L187">            return next;</span>
        } else {
<span class="nc" id="L189">            throw new ParseException(this, nextToken,</span>
                                     &quot;Expected integer, but found '%s' while %s&quot;,
<span class="nc" id="L191">                                     Strings.escape(nextToken.asString()),</span>
                                     message);
        }
    }

    public boolean hasNext() throws IOException, ParseException {
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (nextToken == null) {</span>
<span class="fc" id="L198">            nextToken = nextInternal();</span>
        }
<span class="fc bfc" id="L200" title="All 2 branches covered.">        return nextToken != null;</span>
    }

    @Nullable
    public Token next() throws IOException, ParseException {
<span class="fc bfc" id="L205" title="All 2 branches covered.">        if (nextToken != null) {</span>
<span class="fc" id="L206">            Token tmp = nextToken;</span>
<span class="fc" id="L207">            nextToken = null;</span>
<span class="fc" id="L208">            return tmp;</span>
        }

<span class="fc" id="L211">        return nextInternal();</span>
    }

    private Token nextStringLiteral(int startQuote) throws ParseException {
<span class="fc" id="L215">        int startOffset = readOffset;</span>
<span class="fc" id="L216">        int startLinePos = linePos;</span>
<span class="fc" id="L217">        boolean escaped = false;</span>
        while (true) {
<span class="fc" id="L219">            int r = read();</span>
<span class="pc bpc" id="L220" title="2 of 4 branches missed.">            if (r &lt; 0x20 || r == 0x7F) {</span>
<span class="nc" id="L221">                int pos = startOffset - readOffset;</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">                if (r == -1) {</span>
<span class="nc" id="L223">                    throw new ParseException(</span>
                            this,
                            new Token(buffer, readOffset, 1, lineNo, startLinePos + pos),
                            &quot;Expected end of literal, but got end of file&quot;);
                } else {
<span class="nc" id="L228">                    throw new ParseException(</span>
                            this,
                            new Token(buffer, readOffset, 1, lineNo, startLinePos + pos),
<span class="nc" id="L231">                            &quot;Invalid string literal char '&quot; + Strings.escape(new String(new char[]{(char) r})) + &quot;'&quot;);</span>
                }
            }

<span class="pc bpc" id="L235" title="1 of 2 branches missed.">            if (escaped) {</span>
<span class="nc" id="L236">                escaped = false;</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">            } else if (r == Token.kLiteralEscape) {</span>
<span class="nc" id="L238">                escaped = true;</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">            } else if (startQuote == r) {</span>
<span class="fc" id="L240">                break;</span>
            }
            // else just include into string token.
<span class="fc" id="L243">        }</span>
<span class="fc" id="L244">        return new Token(buffer, startOffset, readOffset - startOffset + 1, lineNo, startLinePos);</span>
    }

    private Token nextInternal() throws IOException, ParseException {
<span class="fc" id="L248">        int startOffset = readOffset;</span>
        int r;
<span class="fc bfc" id="L250" title="All 2 branches covered.">        while ((r = read()) != -1) {</span>
<span class="pc bpc" id="L251" title="2 of 8 branches missed.">            if (r != ' ' &amp;&amp; r != '\t' &amp;&amp; r != '\r' &amp;&amp; r != '\n') {</span>
<span class="fc" id="L252">                startOffset = readOffset;</span>
<span class="fc" id="L253">                break;</span>
            }
        }

<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (r &lt; 0) {</span>
<span class="fc" id="L258">            return null;</span>
        }

        // Known symbols.
<span class="fc bfc" id="L262" title="All 2 branches covered.">        if (Token.kSymbols.indexOf(r) &gt;= 0) {</span>
<span class="fc" id="L263">            return new Token(buffer, startOffset, 1, lineNo, linePos);</span>
        }

        // String literals.
<span class="pc bpc" id="L267" title="1 of 4 branches missed.">        if (r == Token.kLiteralQuote || r == Token.kLiteralDoubleQuote) {</span>
<span class="fc" id="L268">            return nextStringLiteral(r);</span>
        }

        // Number.
<span class="pc bpc" id="L272" title="1 of 8 branches missed.">        if (r == '.' || r == '-' || (r &gt;= '0' &amp;&amp; r &lt;= '9')) {</span>
<span class="fc" id="L273">            return nextNumber(r);</span>
        }

        // Java comment starts (shell comment start is a symbol)
<span class="fc bfc" id="L277" title="All 2 branches covered.">        if (r == Token.kJavaCommentStart) {</span>
            // special case.
<span class="fc" id="L279">            int s = read();</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">            if (s == -1) {</span>
<span class="nc" id="L281">                throw new ParseException(this,</span>
                                         new Token(buffer, readOffset, 1, lineNo, linePos),
                                         &quot;Expected java comment continuation, got end of stream&quot;);
            }
<span class="fc" id="L285">            Token token = new Token(buffer, startOffset, 2, lineNo, linePos++);;</span>
<span class="pc bpc" id="L286" title="1 of 4 branches missed.">            if (s == '/' || s == '*') {</span>
<span class="fc" id="L287">                return token;</span>
<span class="nc bnc" id="L288" title="All 4 branches missed.">            } else if (s &lt; 32 || s &gt;= 127) {</span>
<span class="nc" id="L289">                throw new ParseException(this, token, &quot;Invalid start of comment '/%s'&quot;, Strings.escape(String.valueOf((char)s)));</span>
            } else {
<span class="nc" id="L291">                throw new ParseException(this, token, &quot;Invalid start of comment '/%c'. Must be '/*' or '//'&quot;, (char) s);</span>
            }
        }

        // Identifier / qualified identifier / type name token.
<span class="pc bpc" id="L296" title="4 of 10 branches missed.">        if (r == '_' ||</span>
            (r &gt;= 'a' &amp;&amp; r &lt;= 'z') ||
            (r &gt;= 'A' &amp;&amp; r &lt;= 'Z')) {
<span class="fc" id="L299">            return nextIdentifier();</span>
        }

<span class="nc" id="L302">        throw new ParseException(this,</span>
                                 new Token(buffer, startOffset, readOffset - startOffset, lineNo, linePos),
<span class="nc" id="L304">                                 String.format(&quot;Unknown token initiator: %s&quot;, Strings.escape(String.valueOf((char) r))));</span>
    }

    private Token nextNumber(int lastByte) throws ParseException {
        // NOTE: This code is pretty messy because it is a full state-engine
        // to ensure that the parsed number follows the JSON number syntax.
        // Alternatives are:
        //
        // dec = -?0
        // dec = -?.0
        // dec = -?0.0
        // sci = (dec)[eE][+-]?[0-9]+
        // hex = 0x[0-9a-fA-F]+
        //
        // Octal and hexadecimal numbers are not supported.
        //
        // It is programmed as a state-engine to be very efficient, but
        // correctly detect valid JSON (and what is invalid if not).

<span class="fc" id="L323">        int startLinePos = linePos;</span>
<span class="fc" id="L324">        int startOffset = readOffset;</span>
<span class="fc" id="L325">        int len = 0;</span>

<span class="fc bfc" id="L327" title="All 2 branches covered.">        if (lastByte == '-') {</span>
<span class="fc" id="L328">            lastByte = read();</span>
<span class="fc" id="L329">            ++len;</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">            if (lastByte &lt; 0) {</span>
<span class="nc" id="L331">                throw new ParseException(&quot;Unexpected end of stream on line &quot; + lineNo);</span>
            }

<span class="pc bpc" id="L334" title="3 of 6 branches missed.">            if (!(lastByte == '.' || (lastByte &gt;= '0' &amp;&amp; lastByte &lt;= '9'))) {</span>
<span class="nc" id="L335">                throw new ParseException(this,</span>
                                         new Token(buffer, startOffset, len, lineNo, startLinePos),
                                         &quot;No decimal after negative indicator.&quot;);
            }
<span class="fc bfc" id="L339" title="All 2 branches covered.">        } else if (lastByte == '0') {</span>
<span class="fc" id="L340">            lastByte = read();</span>
<span class="fc" id="L341">            ++len;</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">            if (lastByte == 'x') {</span>
                // hexadecimal.
<span class="nc bnc" id="L344" title="All 2 branches missed.">                while ((lastByte = read()) != -1) {</span>
<span class="nc bnc" id="L345" title="All 12 branches missed.">                    if ((lastByte &gt;= '0' &amp;&amp; lastByte &lt;= '9') ||</span>
                        (lastByte &gt;= 'a' &amp;&amp; lastByte &lt;= 'f') ||
                        (lastByte &gt;= 'A' &amp;&amp; lastByte &lt;= 'F')) {
<span class="nc" id="L348">                        ++len;</span>
<span class="nc" id="L349">                        continue;</span>
                    }
                    // we read a char that's *not* part of the
<span class="nc" id="L352">                    unread();</span>
<span class="nc" id="L353">                    break;</span>
                }

<span class="nc" id="L356">                return new Token(buffer, startOffset, len, lineNo, startLinePos);</span>
            }

            // Octal
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">            while ((lastByte = read()) != -1) {</span>
<span class="fc bfc" id="L361" title="All 4 branches covered.">                if ((lastByte &gt;= '0' &amp;&amp; lastByte &lt;= '7')) {</span>
<span class="fc" id="L362">                    ++len;</span>
<span class="fc" id="L363">                    continue;</span>
                }
                // we read a char that's *not* part of the
<span class="fc" id="L366">                unread();</span>
<span class="fc" id="L367">                break;</span>
            }

<span class="fc" id="L370">            return new Token(buffer, startOffset, len, lineNo, startLinePos);</span>
        }

        // decimal part.
<span class="fc bfc" id="L374" title="All 4 branches covered.">        while (lastByte &gt;= '0' &amp;&amp; lastByte &lt;= '9') {</span>
<span class="fc" id="L375">            ++len;</span>
            // numbers are terminated by first non-numeric character.
<span class="fc" id="L377">            lastByte = read();</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">            if (lastByte &lt; 0) {</span>
<span class="nc" id="L379">                break;</span>
            }
        }
        // fraction part.
<span class="fc bfc" id="L383" title="All 2 branches covered.">        if (lastByte == '.') {</span>
<span class="fc" id="L384">            ++len;</span>
            // numbers are terminated by first non-numeric character.
<span class="fc" id="L386">            lastByte = read();</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">            if (lastByte &gt;= 0) {</span>
<span class="pc bpc" id="L388" title="1 of 4 branches missed.">                while (lastByte &gt;= '0' &amp;&amp; lastByte &lt;= '9') {</span>
<span class="fc" id="L389">                    ++len;</span>
                    // numbers are terminated by first non-numeric character.
<span class="fc" id="L391">                    lastByte = read();</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">                    if (lastByte &lt; 0) {</span>
<span class="nc" id="L393">                        break;</span>
                    }
                }
            }
        }
        // exponent part.
<span class="pc bpc" id="L399" title="2 of 4 branches missed.">        if (lastByte == 'e' || lastByte == 'E') {</span>
<span class="nc" id="L400">            ++len;</span>
            // numbers are terminated by first non-numeric character.
<span class="nc" id="L402">            lastByte = read();</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">            if (lastByte &gt;= 0) {</span>
                // The exponent can be explicitly prefixed with both '+'
                // and '-'.
<span class="nc bnc" id="L406" title="All 4 branches missed.">                if (lastByte == '-' || lastByte == '+') {</span>
<span class="nc" id="L407">                    ++len;</span>
                    // numbers are terminated by first non-numeric character.
<span class="nc" id="L409">                    lastByte = read();</span>
                }

<span class="nc bnc" id="L412" title="All 4 branches missed.">                while (lastByte &gt;= '0' &amp;&amp; lastByte &lt;= '9') {</span>
<span class="nc" id="L413">                    ++len;</span>
                    // numbers are terminated by first non-numeric character.
<span class="nc" id="L415">                    lastByte = read();</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">                    if (lastByte &lt; 0) {</span>
<span class="nc" id="L417">                        break;</span>
                    }
                }
            }
        }
<span class="fc" id="L422">        Token token = new Token(buffer, startOffset, len, lineNo, startLinePos);</span>

        // A number must be terminated correctly: End of stream, space, newline
        // or a symbol that may be after a value: ':', ',' ';' '}' ')'.
<span class="pc bpc" id="L426" title="12 of 24 branches missed.">        if (lastByte &lt; 0 ||</span>
            lastByte == ' ' ||
            lastByte == '\t' ||
            lastByte == '\n' ||
            lastByte == '\r' ||
            lastByte == Token.kFieldIdSep ||
            lastByte == Token.kMessageEnd ||
            lastByte == Token.kLineSep1 ||
            lastByte == Token.kLineSep2 ||
            lastByte == Token.kJavaCommentStart ||
            lastByte == Token.kShellComment ||
            lastByte == Token.kParamsEnd) {
<span class="fc bfc" id="L438" title="All 2 branches covered.">            if (Token.kSymbols.indexOf(lastByte) &gt;= 0) {</span>
<span class="fc" id="L439">                unread();</span>
            }
<span class="fc" id="L441">            return token;</span>
        } else {
<span class="nc" id="L443">            throw new ParseException(this, token, &quot;Wrongly terminated number: %c.&quot;, (char) lastByte);</span>
        }
    }

    private Token nextIdentifier() throws ParseException {
<span class="fc" id="L448">        int startOffset = readOffset;</span>
<span class="fc" id="L449">        int startLinePos = linePos;</span>

<span class="fc" id="L451">        int len = 1, r;</span>
<span class="fc" id="L452">        boolean dot = false;</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">        while ((r = read()) != -1) {</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">            if (r == '.') {</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">                if (dot) {</span>
<span class="fc" id="L456">                    Token token = new Token(buffer, startOffset, len, lineNo, startLinePos);</span>
<span class="fc" id="L457">                    throw new ParseException(this, token, &quot;Identifier with double '..' at line %d pos %d&quot;, lineNo, startLinePos);</span>
                }
<span class="fc" id="L459">                dot = true;</span>
<span class="fc" id="L460">                ++len;</span>
<span class="fc" id="L461">                continue;</span>
            }
<span class="fc" id="L463">            dot = false;</span>

<span class="pc bpc" id="L465" title="2 of 14 branches missed.">            if (r == '_' ||</span>
                (r &gt;= '0' &amp;&amp; r &lt;= '9') ||
                (r &gt;= 'a' &amp;&amp; r &lt;= 'z') ||
                (r &gt;= 'A' &amp;&amp; r &lt;= 'Z')) {
<span class="fc" id="L469">                ++len;</span>
<span class="fc" id="L470">                continue;</span>
            }

<span class="fc" id="L473">            unread();</span>
<span class="fc" id="L474">            break;</span>
        }
<span class="fc" id="L476">        Token token = new Token(buffer, startOffset, len, lineNo, startLinePos);</span>

<span class="pc bpc" id="L478" title="1 of 2 branches missed.">        if (dot) {</span>
<span class="nc" id="L479">            throw new ParseException(this, token, &quot;Identifier trailing with '.' at line %d pos &amp;d&quot;, lineNo, startLinePos);</span>
        }

<span class="pc bpc" id="L482" title="4 of 12 branches missed.">        if (r == -1 ||</span>
            r == ' ' ||
            r == '\t' ||
            r == '\n' ||
            r == '\r' ||
            r == Token.kJavaCommentStart ||
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">            Token.kSymbols.indexOf(r) &gt;= 0) {</span>
<span class="fc" id="L489">            return token;</span>
        } else {
<span class="nc" id="L491">            throw new ParseException(this, token, &quot;Wrongly terminated identifier: %c.&quot;, (char) r);</span>
        }
    }

    public String getLine(int line) throws IOException {
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">        if (line &lt; 1) {</span>
<span class="nc" id="L497">            throw new IllegalArgumentException(&quot;Oops!!!&quot;);</span>
        }
        // reset read position.
<span class="fc" id="L500">        readOffset = -1;</span>
<span class="fc" id="L501">        lineNo = 1;</span>
<span class="fc" id="L502">        linePos = -1;</span>

<span class="fc bfc" id="L504" title="All 2 branches covered.">        while (--line &gt; 0) {</span>
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">            if (!IOUtils.skipUntil(this, (byte) '\n')) {</span>
<span class="nc" id="L506">                throw new IOException(&quot;Oops&quot;);</span>
            }
        }
<span class="fc" id="L509">        return IOUtils.readString(this, &quot;\n&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>