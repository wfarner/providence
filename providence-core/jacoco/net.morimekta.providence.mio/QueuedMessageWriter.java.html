<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QueuedMessageWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Providence Core</a> &gt; <a href="index.source.html" class="el_package">net.morimekta.providence.mio</a> &gt; <span class="el_source">QueuedMessageWriter.java</span></div><h1>QueuedMessageWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015-2016 Providence Authors
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package net.morimekta.providence.mio;

import net.morimekta.providence.PMessage;
import net.morimekta.providence.PServiceCall;
import net.morimekta.providence.descriptor.PField;

import com.google.common.annotations.Beta;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * A queued message writer that takes in messages onto a queue, and let
 * a single thread handle all the writes to the contained writer. This
 * writer is thread safe, and should be much faster than having multiple
 * threads fight over the file IO.
 * &lt;p&gt;
 * Note that the writer will continue to accept messages after it has been
 * closed.
 */
@Beta
public class QueuedMessageWriter implements MessageWriter {
<span class="fc" id="L51">    private static final Logger LOGGER = LoggerFactory.getLogger(QueuedMessageWriter.class);</span>

    private final Queue&lt;PMessage&gt; messageQueue;
    private final Queue&lt;PServiceCall&gt; callQueue;
    private final ExecutorService executor;
    private final MessageWriter   writer;

    /**
     * Create a queued message writer.
     *
     * @param writer The message writer to write to.
     */
    public QueuedMessageWriter(MessageWriter writer) {
<span class="fc" id="L64">        this(writer, Executors.newSingleThreadExecutor(</span>
                new ThreadFactoryBuilder()
<span class="fc" id="L66">                        .setDaemon(true)</span>
<span class="fc" id="L67">                        .setNameFormat(&quot;providence-queued-writer&quot;)</span>
<span class="fc" id="L68">                        .build()));</span>
<span class="fc" id="L69">    }</span>

    /**
     * Create a queued message writer using the given executor service.
     * Note that the executor service will be shut down with the message queue.
     *
     * @param writer The message writer to write to.
     * @param executor The executor service running the write loop thread.
     */
    public QueuedMessageWriter(MessageWriter writer,
<span class="fc" id="L79">                               ExecutorService executor) {</span>
<span class="fc" id="L80">        this.writer = writer;</span>
<span class="fc" id="L81">        this.executor = executor;</span>
<span class="fc" id="L82">        this.messageQueue = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="fc" id="L83">        this.callQueue = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="fc" id="L84">        this.executor.submit(this::writeLoop);</span>
<span class="fc" id="L85">    }</span>

    @Override
    public &lt;Message extends PMessage&lt;Message, Field&gt;, Field extends PField&gt;
    int write(Message message) throws IOException {
<span class="fc" id="L90">        messageQueue.offer(message);</span>
<span class="fc" id="L91">        return 1;</span>
    }

    @Override
    public &lt;Message extends PMessage&lt;Message, Field&gt;, Field extends PField&gt;
    int write(PServiceCall&lt;Message, Field&gt; call) throws IOException {
<span class="fc" id="L97">        callQueue.offer(call);</span>
<span class="fc" id="L98">        return 1;</span>
    }

    @Override
    public int separator() throws IOException {
<span class="fc" id="L103">        return 0;</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void close() throws IOException {
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (!executor.isShutdown()) {</span>
            try {
<span class="fc" id="L111">                executor.shutdown();</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">                if (!executor.awaitTermination(1000L, TimeUnit.MILLISECONDS)) {</span>
<span class="fc" id="L113">                    executor.shutdownNow();</span>
                }
<span class="fc" id="L115">            } catch (InterruptedException e) {</span>
<span class="fc" id="L116">                LOGGER.error(&quot;Interrupted while stopping writer loop thread&quot;, e);</span>
<span class="fc" id="L117">                throw new RuntimeException(e.getMessage(), e);</span>
            } finally {
<span class="fc" id="L119">                try {</span>
<span class="pc bpc" id="L120" title="1 of 4 branches missed.">                    while (messageQueue.size() &gt; 0) {</span>
<span class="pc" id="L121">                        writer.write(messageQueue.poll());</span>
<span class="pc" id="L122">                        writer.separator();</span>
                    }
<span class="pc bpc" id="L124" title="2 of 4 branches missed.">                    while (callQueue.size() &gt; 0) {</span>
<span class="pc" id="L125">                        writer.write(callQueue.poll());</span>
<span class="pc" id="L126">                        writer.separator();</span>
                    }
<span class="pc" id="L128">                } catch (IOException e) {</span>
<span class="pc" id="L129">                    LOGGER.error(&quot;Unable to write messages on close&quot;, e);</span>
<span class="pc" id="L130">                }</span>
<span class="fc" id="L131">                writer.close();</span>
<span class="fc" id="L132">            }</span>
        }
<span class="fc" id="L134">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private void writeLoop() {
        try {
<span class="fc" id="L139">            long failDelay = 137L;</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">            while (!executor.isShutdown()) {</span>
                try {
<span class="fc bfc" id="L142" title="All 2 branches covered.">                    while (messageQueue.size() &gt; 0) {</span>
<span class="fc" id="L143">                        writer.write(messageQueue.poll());</span>
<span class="fc" id="L144">                        failDelay = 137L;</span>
                    }
<span class="fc bfc" id="L146" title="All 2 branches covered.">                    while (callQueue.size() &gt; 0) {</span>
<span class="fc" id="L147">                        writer.write(callQueue.poll());</span>
<span class="fc" id="L148">                        failDelay = 137L;</span>
                    }
<span class="fc" id="L150">                    sleep(3L);  // 3ms should be enough to do actual work.</span>
                    // This is a very tight loop, so should be expensive to
                    // to have a short sleep time.
<span class="fc" id="L153">                } catch (IOException e) {</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">                    if (failDelay &gt;= 10_000) {</span>
<span class="nc" id="L155">                        LOGGER.error(&quot;Unable to write message, sleeping {}s&quot;,</span>
<span class="nc" id="L156">                                     (failDelay / 1000), e);</span>
                    } else {
<span class="fc" id="L158">                        LOGGER.error(&quot;Unable to write message, sleeping {}ms&quot;,</span>
<span class="fc" id="L159">                                     failDelay, e);</span>
                    }

                    // Continue but with longer sleep on errors.
                    try {
<span class="fc" id="L164">                        sleep(failDelay);</span>
                    } finally {
<span class="pc" id="L166">                        failDelay = Math.min(</span>
<span class="pc" id="L167">                                TimeUnit.MINUTES.toMillis(10),</span>
                                // add 2/3 to the time for each consecutive failure.
                                (long) (failDelay * 1.66666667));
<span class="fc" id="L170">                    }</span>
<span class="fc" id="L171">                }</span>
            }
<span class="nc" id="L173">        } catch (InterruptedException ignore) {</span>
            // thread is interrupted, just stop. Not tested.
<span class="nc" id="L175">            Thread.currentThread().interrupt();</span>
<span class="fc" id="L176">        }</span>
<span class="fc" id="L177">    }</span>

    @VisibleForTesting
    protected void sleep(long ms) throws InterruptedException {
<span class="fc" id="L181">        Thread.sleep(ms);</span>
<span class="fc" id="L182">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>