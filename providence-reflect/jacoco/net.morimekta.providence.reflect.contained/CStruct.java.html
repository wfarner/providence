<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CStruct.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Providence Utils : Reflection</a> &gt; <a href="index.source.html" class="el_package">net.morimekta.providence.reflect.contained</a> &gt; <span class="el_source">CStruct.java</span></div><h1>CStruct.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016 Providence Authors
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package net.morimekta.providence.reflect.contained;

import net.morimekta.providence.PMessage;
import net.morimekta.providence.PMessageBuilder;
import net.morimekta.providence.descriptor.PField;
import net.morimekta.providence.descriptor.PMessageDescriptor;
import net.morimekta.providence.serializer.PrettySerializer;
import net.morimekta.providence.serializer.json.JsonCompactible;
import net.morimekta.providence.serializer.json.JsonCompactibleDescriptor;

import javax.annotation.Nonnull;
import java.io.ByteArrayOutputStream;
import java.util.Map;
import java.util.Objects;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * A contained message of variant struct.
 */
public class CStruct implements CMessage&lt;CStruct&gt;, JsonCompactible {
<span class="fc" id="L42">    private static final PrettySerializer PRETTY_SERIALIZER = new PrettySerializer().compact();</span>

    Map&lt;Integer,Object&gt; values;
    CStructDescriptor   descriptor;

<span class="fc" id="L47">    private CStruct(Builder builder) {</span>
<span class="fc" id="L48">        descriptor = builder.descriptor;</span>
<span class="fc" id="L49">        values     = builder.getValueMap();</span>
<span class="fc" id="L50">    }</span>

    public Map&lt;Integer,Object&gt; values() {
<span class="fc" id="L53">        return values;</span>
    }

    @Override
    public boolean jsonCompact() {
<span class="nc" id="L58">        PMessageDescriptor&lt;CStruct, CField&gt; descriptor = descriptor();</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">        if (!((JsonCompactibleDescriptor) descriptor).isJsonCompactible()) {</span>
<span class="nc" id="L60">            return false;</span>
        }
<span class="nc" id="L62">        boolean missing = false;</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">        for (CField field : descriptor.getFields()) {</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">            if (has(field.getId())) {</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">                if (missing) {</span>
<span class="nc" id="L66">                    return false;</span>
                }
            } else {
<span class="nc" id="L69">                missing = true;</span>
            }
        }
<span class="nc" id="L72">        return true;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L77" title="2 of 6 branches missed.">        return this == o ||</span>
               !(o == null ||
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">                 !(o instanceof CStruct)) &amp;&amp; equals(this, (CStruct) o);</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L84">        return hashCode(this);</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L89">        return descriptor().getQualifiedName() + asString();</span>
    }

    @Nonnull
    @Override
    public PMessageBuilder&lt;CStruct,CField&gt; mutate() {
<span class="fc" id="L95">        return new Builder(descriptor).merge(this);</span>
    }

    @Nonnull
    @Override
    public CStructDescriptor descriptor() {
<span class="fc" id="L101">        return descriptor;</span>
    }

    public static class Builder extends CMessageBuilder&lt;Builder,CStruct&gt; {
        private final CStructDescriptor descriptor;

<span class="fc" id="L107">        public Builder(CStructDescriptor descriptor) {</span>
<span class="fc" id="L108">            this.descriptor = descriptor;</span>
<span class="fc" id="L109">        }</span>

        @Nonnull
        @Override
        public CStructDescriptor descriptor() {
<span class="fc" id="L114">            return descriptor;</span>
        }

        @Nonnull
        @Override
        public CStruct build() {
<span class="fc" id="L120">            return new CStruct(this);</span>
        }
    }

    protected static &lt;M extends PMessage&lt;M, CField&gt;&gt; boolean equals(M a, M b) {
<span class="fc" id="L125">        PMessageDescriptor&lt;?, ?&gt; type = b.descriptor();</span>
<span class="fc" id="L126">        if (!a.descriptor()</span>
<span class="fc" id="L127">                 .getQualifiedName()</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">                 .equals(type.getQualifiedName()) ||</span>
<span class="fc" id="L129">            !a.descriptor()</span>
<span class="fc" id="L130">                 .getVariant()</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">                 .equals(type.getVariant())) {</span>
<span class="nc" id="L132">            return false;</span>
        }

<span class="fc bfc" id="L135" title="All 2 branches covered.">        for (CField field : a.descriptor().getFields()) {</span>
<span class="fc" id="L136">            int id = field.getId();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">            if (a.has(id) != b.has(id)) {</span>
<span class="fc" id="L138">                return false;</span>
            }
<span class="fc bfc" id="L140" title="All 2 branches covered.">            if (!Objects.equals(a.get(id), b.get(id))) {</span>
<span class="fc" id="L141">                return false;</span>
            }
        }
<span class="fc" id="L144">        return true;</span>
    }

    protected static &lt;M extends CMessage&lt;M&gt;&gt; int hashCode(M self) {
<span class="fc" id="L148">        int hash = self.descriptor().hashCode();</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">        for (CField field : self.descriptor().getFields()) {</span>
<span class="fc" id="L150">            hash *= 29251;</span>
<span class="fc" id="L151">            hash ^= Objects.hash(field, self.get(field));</span>
        }
<span class="fc" id="L153">        return hash;</span>
    }

    /**
     * Prints a jsonCompact string representation of the message.
     *
     * @param message The message to stringify.
     * @param &lt;Message&gt; The contained message type.
     * @return The resulting string.
     */
    protected static &lt;Message extends PMessage&lt;Message, CField&gt;&gt;
    String asString(Message message) {
<span class="fc" id="L165">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L166">        PRETTY_SERIALIZER.serialize(baos, message);</span>
<span class="fc" id="L167">        return new String(baos.toByteArray(), UTF_8);</span>
    }

    /**
     * Compare two values to each other.
     *
     * @param o1 The first value.
     * @param o2 The second value.
     * @param &lt;T&gt; The object type.
     * @return The compare value (-1, 0 or 1).
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private static &lt;T extends Comparable&lt;T&gt;&gt; int compare(T o1, T o2) {
<span class="pc bpc" id="L180" title="2 of 4 branches missed.">        if (o1 == null || o2 == null) {</span>
<span class="nc bnc" id="L181" title="All 4 branches missed.">            return Boolean.compare(o1 != null, o2 != null);</span>
<span class="pc bpc" id="L182" title="3 of 4 branches missed.">        } else if (o1 instanceof PMessage &amp;&amp; o2 instanceof PMessage) {</span>
<span class="nc" id="L183">            return compareMessages((PMessage) o1, (PMessage) o2);</span>
        }
<span class="fc" id="L185">        return o1.compareTo(o2);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T extends PMessage&lt;T, F&gt;, F extends PField&gt; int compareMessages(T m1, T m2) {
<span class="fc" id="L190">        int c = m1.descriptor()</span>
<span class="fc" id="L191">                  .getQualifiedName()</span>
<span class="fc" id="L192">                  .compareTo(m2.descriptor()</span>
<span class="fc" id="L193">                               .getQualifiedName());</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">        if (c != 0) {</span>
<span class="nc" id="L195">            return c;</span>
        }
<span class="fc bfc" id="L197" title="All 2 branches covered.">        for (PField field : m1.descriptor()</span>
<span class="fc" id="L198">                              .getFields()) {</span>
<span class="fc" id="L199">            c = Boolean.compare(m1.has(field.getId()), m2.has(field.getId()));</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">            if (c != 0) {</span>
<span class="nc" id="L201">                return c;</span>
            }
<span class="fc bfc" id="L203" title="All 2 branches covered.">            if (m1.has(field.getId())) {</span>
<span class="fc" id="L204">                c = compare((Comparable) m1.get(field.getId()), (Comparable) m2.get(field.getId()));</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">                if (c != 0) {</span>
<span class="fc" id="L206">                    return c;</span>
                }
            }
        }
<span class="fc" id="L210">        return 0;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>