<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Tokenizer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Providence Core</a> &gt; <a href="index.source.html" class="el_package">net.morimekta.providence.serializer.pretty</a> &gt; <span class="el_source">Tokenizer.java</span></div><h1>Tokenizer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015-2016 Providence Authors
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package net.morimekta.providence.serializer.pretty;

import net.morimekta.util.Slice;
import net.morimekta.util.Strings;
import net.morimekta.util.io.IOUtils;

import javax.annotation.Nonnull;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UncheckedIOException;

/**
 * Simple tokenizer for the pretty serializer that strips away comments based
 * on the &quot;#&quot; (shell) comment character. Each comment lasts until the next
 * newline.
 */
public class Tokenizer extends InputStream {
    @FunctionalInterface
    public interface TokenValidator {
        boolean validate(Token token);
    }

    private final byte[] buffer;
    protected     int    readOffset;
    protected     int    lineNo;
    protected     int    linePos;
    private       Token  nextToken;

<span class="fc" id="L50">    public Tokenizer(InputStream in, boolean enclosedContent) throws IOException {</span>
<span class="fc" id="L51">        ByteArrayOutputStream tmp = new ByteArrayOutputStream();</span>
<span class="fc bfc" id="L52" title="All 2 branches covered.">        if (enclosedContent) {</span>
<span class="fc" id="L53">            int stack = 0;</span>
<span class="fc" id="L54">            char literal = '\0';</span>
<span class="fc" id="L55">            boolean escaped = false;</span>
<span class="fc" id="L56">            boolean comment = false;</span>

            int r;
<span class="fc bfc" id="L59" title="All 2 branches covered.">            while ((r = in.read()) &gt;= 0) {</span>
<span class="fc" id="L60">                tmp.write(r);</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">                if (comment) {</span>
<span class="fc bfc" id="L62" title="All 4 branches covered.">                    if (r == '\n' || r == '\r') {</span>
<span class="fc" id="L63">                        comment = false;</span>
                    }
                } else {
<span class="fc bfc" id="L66" title="All 2 branches covered.">                    if (literal != '\0') {</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">                        if (escaped) {</span>
<span class="fc" id="L68">                            escaped = false;</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">                        } else if (r == literal) {</span>
<span class="fc" id="L70">                            literal = '\0';</span>
<span class="fc" id="L71">                            escaped = false;</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">                        } else if (r == '\\') {</span>
<span class="fc" id="L73">                            escaped = true;</span>
                        }
<span class="pc bpc" id="L75" title="1 of 8 branches missed.">                    } else if (r == ' ' || r == '\t' || r == '\r' || r == '\n') {</span>
                        // just continue.
<span class="pc bpc" id="L77" title="1 of 4 branches missed.">                    } else if (r == '\&quot;' || r == '\'') {</span>
<span class="fc" id="L78">                        literal = (char) r;</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">                    } else if (r == '#') {</span>
<span class="fc" id="L80">                        comment = true;</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">                    } else if (r == '}') {</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">                        if (--stack &lt;= 0) {</span>
<span class="fc" id="L83">                            break;</span>
                        }
<span class="fc bfc" id="L85" title="All 2 branches covered.">                    } else if (r == '{') {</span>
<span class="fc" id="L86">                        ++stack;</span>
                    }
                }
            }
<span class="fc" id="L90">        } else {</span>
<span class="fc" id="L91">            IOUtils.copy(in, tmp);</span>
        }

<span class="fc" id="L94">        this.buffer = tmp.toByteArray();</span>
<span class="fc" id="L95">        this.readOffset = -1;</span>

<span class="fc" id="L97">        this.lineNo = 1;</span>
<span class="fc" id="L98">        this.linePos = 0;</span>
<span class="fc" id="L99">    }</span>

    @Override
    public int read() {
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (++readOffset &gt;= buffer.length) {</span>
<span class="fc" id="L104">            readOffset = buffer.length;</span>
<span class="fc" id="L105">            return -1;</span>
        }
<span class="fc" id="L107">        int ret = buffer[readOffset];</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">        if (ret == '\n') {</span>
<span class="fc" id="L109">            ++lineNo;</span>
<span class="fc" id="L110">            linePos = 0;</span>
        } else {
<span class="fc" id="L112">            ++linePos;</span>
        }
<span class="fc bfc" id="L114" title="All 2 branches covered.">        return ret &gt; 0 ? ret : 0x100 + ret;</span>
    }

    /**
     * &quot;Unread&quot; the last read byte. Note that line-pos is not usable
     * immediately after reading, until reading again.
     */
    private void unread() {
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">        if (readOffset == buffer.length) {</span>
<span class="nc" id="L123">            --readOffset;</span>
<span class="nc" id="L124">            return;</span>
        }

<span class="fc bfc" id="L127" title="All 2 branches covered.">        if (buffer[readOffset--] == '\n') {</span>
<span class="fc" id="L128">            --lineNo;</span>
        } else {
<span class="fc" id="L130">            --linePos;</span>
        }
<span class="fc" id="L132">    }</span>

    /**
     * Expect at a valid token containing anything.
     *
     * @param expected The expectation description.
     * @return The token.
     * @throws IOException If failed to read a token.
     */
    public Token expect(@Nonnull String expected) throws IOException {
<span class="fc bfc" id="L142" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L143">            throw failure(&quot;Expected %s, got end of file&quot;, expected);</span>
        }
<span class="fc" id="L145">        Token next = nextToken;</span>
<span class="fc" id="L146">        nextToken = null;</span>
<span class="fc" id="L147">        return next;</span>
    }

    public Token expect(@Nonnull String expected,
                        @Nonnull TokenValidator validator) throws IOException {
<span class="fc bfc" id="L152" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L153">            throw failure(&quot;Expected %s, got end of file&quot;, expected);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        } else if (validator.validate(nextToken)) {</span>
<span class="fc" id="L155">            Token next = nextToken;</span>
<span class="fc" id="L156">            nextToken = null;</span>
<span class="fc" id="L157">            return next;</span>
        }
<span class="fc" id="L159">        throw failure(nextToken,</span>
                      &quot;Expected %s, but got '%s'&quot;,
                      expected,
<span class="fc" id="L162">                      Strings.escape(nextToken.asString()));</span>
    }

    public Token peek(@Nonnull String expected) throws IOException {
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        if (!hasNext()) {</span>
<span class="fc" id="L167">            throw failure(&quot;Expected %s, got end of file&quot;, expected);</span>
        }
<span class="nc" id="L169">        return nextToken;</span>
    }

    public Token peek() throws IOException {
<span class="fc" id="L173">        hasNext();</span>
<span class="fc" id="L174">        return nextToken;</span>
    }

    public char expectSymbol(@Nonnull String expected, char... symbols) throws IOException {
<span class="fc bfc" id="L178" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L179">            throw failure(&quot;Expected %s, one of ['%s'], got end of file&quot;,</span>
                                         expected,
<span class="fc" id="L181">                                         Strings.joinP(&quot;', '&quot;, symbols));</span>
        } else {
<span class="fc bfc" id="L183" title="All 2 branches covered.">            for (char symbol : symbols) {</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">                if (nextToken.isSymbol(symbol)) {</span>
<span class="fc" id="L185">                    nextToken = null;</span>
<span class="fc" id="L186">                    return symbol;</span>
                }
            }

<span class="fc" id="L190">            throw failure(nextToken,</span>
                          &quot;Expected %s, one of ['%s'], but found '%s'&quot;,
                          expected,
<span class="fc" id="L193">                          Strings.joinP(&quot;', '&quot;, symbols),</span>
<span class="fc" id="L194">                          Strings.escape(nextToken.asString()));</span>
        }
    }

    public Token expectIdentifier(@Nonnull String message) throws IOException {
<span class="fc" id="L199">        return expect(message, Token::isIdentifier);</span>
    }

    @Nonnull
    public Token expectInteger(String message) throws IOException {
<span class="nc" id="L204">        return expect(message, Token::isInteger);</span>
    }

    @Nonnull
    public Token expectLiteral(String message) throws IOException {
<span class="nc" id="L209">        return expect(message, Token::isStringLiteral);</span>
    }

    public boolean hasNext() throws IOException {
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (nextToken == null) {</span>
<span class="fc" id="L214">            nextToken = nextInternal();</span>
        }
<span class="fc bfc" id="L216" title="All 2 branches covered.">        return nextToken != null;</span>
    }

    public Token next() throws IOException {
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (nextToken != null) {</span>
<span class="fc" id="L221">            Token tmp = nextToken;</span>
<span class="fc" id="L222">            nextToken = null;</span>
<span class="fc" id="L223">            return tmp;</span>
        }

<span class="fc" id="L226">        return nextInternal();</span>
    }

    private Token nextStringLiteral(int startQuote) throws TokenizerException {
<span class="fc" id="L230">        int startOffset = readOffset;</span>
<span class="fc" id="L231">        int startLinePos = linePos;</span>
<span class="fc" id="L232">        int startLineNo = lineNo;</span>
<span class="fc" id="L233">        boolean escaped = false;</span>
        while (true) {
<span class="fc" id="L235">            int r = read();</span>
<span class="pc bpc" id="L236" title="1 of 4 branches missed.">            if (r &lt; 0x20 || r == 0x7F) {</span>
<span class="fc" id="L237">                int length = readOffset - startOffset;</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">                if (r == -1) {</span>
<span class="fc" id="L239">                    throw failure(startLineNo, startLinePos, length,</span>
                                  &quot;Unexpected end of stream in literal&quot;);
<span class="pc bpc" id="L241" title="1 of 4 branches missed.">                } else if (r == '\n' || r == '\r') {</span>
<span class="fc" id="L242">                    throw failure(startLineNo, startLinePos, length - 1,</span>
                                  &quot;Unexpected line break in literal&quot;);
                } else {
<span class="fc" id="L245">                    throw failure(startLineNo, startLinePos, length + 1,</span>
                                  &quot;Unescaped non-printable char in literal: '%s'&quot;,
<span class="fc" id="L247">                                  escapeChar(r));</span>
                }
            }

<span class="fc bfc" id="L251" title="All 2 branches covered.">            if (escaped) {</span>
<span class="fc" id="L252">                escaped = false;</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">            } else if (r == Token.kLiteralEscape) {</span>
<span class="fc" id="L254">                escaped = true;</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">            } else if (startQuote == r) {</span>
<span class="fc" id="L256">                break;</span>
            }
            // else just include into string token.
<span class="fc" id="L259">        }</span>
<span class="fc" id="L260">        return token(startOffset, readOffset - startOffset + 1, startLinePos);</span>
    }

    private Token nextInternal() throws IOException {
        int r;
<span class="fc bfc" id="L265" title="All 2 branches covered.">        while ((r = read()) != -1) {</span>
<span class="pc bpc" id="L266" title="1 of 8 branches missed.">            if (r != ' ' &amp;&amp; r != '\t' &amp;&amp; r != '\r' &amp;&amp; r != '\n') {</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">                if (r == Token.kShellComment) {</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">                    while ((r = read()) != -1) {</span>
<span class="fc bfc" id="L269" title="All 4 branches covered.">                        if (r == '\n' || r == '\r') {</span>
<span class="fc" id="L270">                            break;</span>
                        }
                    }
                } else {
                    break;
                }
            }
        }

<span class="fc bfc" id="L279" title="All 2 branches covered.">        if (r &lt; 0) {</span>
<span class="fc" id="L280">            return null;</span>
        }

        // Known symbols.
<span class="fc bfc" id="L284" title="All 2 branches covered.">        if (Token.kSymbols.indexOf(r) &gt;= 0) {</span>
<span class="fc" id="L285">            return nextSymbol(r);</span>
        }

        // String literals.
<span class="pc bpc" id="L289" title="1 of 4 branches missed.">        if (r == Token.kLiteralQuote || r == Token.kLiteralDoubleQuote) {</span>
<span class="fc" id="L290">            return nextStringLiteral(r);</span>
        }

        // Number.
<span class="pc bpc" id="L294" title="1 of 8 branches missed.">        if (r == '.' || r == '-' || (r &gt;= '0' &amp;&amp; r &lt;= '9')) {</span>
<span class="fc" id="L295">            return nextNumber(r);</span>
        }

        // Identifier / qualified identifier / type name token.
<span class="pc bpc" id="L299" title="3 of 10 branches missed.">        if (r == '_' || (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= 'A' &amp;&amp; r &lt;= 'Z')) {</span>
<span class="fc" id="L300">            return nextIdentifier();</span>
        }

<span class="fc" id="L303">        throw failure(lineNo, linePos, 1, &quot;Unknown token initiator '%c'&quot;, r);</span>
    }

    protected Token nextSymbol(int lastByte) throws TokenizerException {
<span class="fc" id="L307">        return token(readOffset, 1, linePos);</span>
    }

    private Token nextNumber(int lastByte) throws TokenizerException {
        // NOTE: This code is pretty messy because it is a full state-engine
        // to ensure that the parsed number follows the JSON number syntax.
        // Alternatives are:
        //
        // dec = -?0
        // dec = -?.0
        // dec = -?0.0
        // sci = (dec)[eE][+-]?[0-9]+
        // hex = 0x[0-9a-fA-F]+
        //
        // Octal and hexadecimal numbers are not supported.
        //
        // It is programmed as a state-engine to be very efficient, but
        // correctly detect valid JSON (and what is invalid if not).

<span class="fc" id="L326">        int startLinePos = linePos;</span>
<span class="fc" id="L327">        int startLineNo = lineNo;</span>
<span class="fc" id="L328">        int startOffset = readOffset;</span>
<span class="fc" id="L329">        int len = 0;</span>

<span class="fc bfc" id="L331" title="All 2 branches covered.">        if (lastByte == '-') {</span>
<span class="fc" id="L332">            lastByte = read();</span>
<span class="fc" id="L333">            ++len;</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">            if (lastByte &lt; 0) {</span>
<span class="fc" id="L335">                throw failure(startLineNo, startLinePos, len,</span>
                              &quot;Unexpected end of stream after negative indicator&quot;);
            }
<span class="pc bpc" id="L338" title="2 of 6 branches missed.">            if (!(lastByte == '.' || (lastByte &gt;= '0' &amp;&amp; lastByte &lt;= '9'))) {</span>
<span class="fc" id="L339">                throw failure(startLineNo, startLinePos, len,</span>
                              &quot;No decimal after negative indicator&quot;);
            }
<span class="fc bfc" id="L342" title="All 2 branches covered.">        } else if (lastByte == '0') {</span>
<span class="fc" id="L343">            lastByte = read();</span>
<span class="fc" id="L344">            ++len;</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">            if (lastByte == 'x') {</span>
<span class="fc" id="L346">                ++len;</span>
                // hexadecimal.
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">                while ((lastByte = read()) != -1) {</span>
<span class="pc bpc" id="L349" title="7 of 12 branches missed.">                    if ((lastByte &gt;= '0' &amp;&amp; lastByte &lt;= '9') || (lastByte &gt;= 'a' &amp;&amp; lastByte &lt;= 'f') ||</span>
                        (lastByte &gt;= 'A' &amp;&amp; lastByte &lt;= 'F')) {
<span class="fc" id="L351">                        ++len;</span>
<span class="fc" id="L352">                        continue;</span>
                    }
                    // we read a char that's *not* part of the
                    break;
                }

<span class="fc" id="L358">                return validateAfterNumber(lastByte, startOffset, startLinePos, len);</span>
<span class="fc bfc" id="L359" title="All 4 branches covered.">            } else if ('0' &lt;= lastByte &amp;&amp; lastByte &lt;= '7') {</span>
<span class="fc" id="L360">                ++len;</span>
                // Octals have 0 in front, and then more digits.
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">                while ((lastByte = read()) != -1) {</span>
<span class="pc bpc" id="L363" title="1 of 4 branches missed.">                    if ((lastByte &lt; '0' || lastByte &gt; '7')) {</span>
<span class="fc" id="L364">                        ++len;</span>
<span class="fc" id="L365">                        break;</span>
                    }
                }

<span class="fc" id="L369">                return validateAfterNumber(lastByte, startOffset, startLinePos, len);</span>
            }

        }

        // decimal part.
<span class="fc bfc" id="L375" title="All 4 branches covered.">        while (lastByte &gt;= '0' &amp;&amp; lastByte &lt;= '9') {</span>
<span class="fc" id="L376">            ++len;</span>
            // numbers are terminated by first non-numeric character.
<span class="fc" id="L378">            lastByte = read();</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">            if (lastByte &lt; 0) {</span>
<span class="fc" id="L380">                break;</span>
            }
        }
        // fraction part.
<span class="fc bfc" id="L384" title="All 2 branches covered.">        if (lastByte == '.') {</span>
<span class="fc" id="L385">            ++len;</span>
            // numbers are terminated by first non-numeric character.
<span class="fc" id="L387">            lastByte = read();</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">            if (lastByte &gt;= 0) {</span>
<span class="fc bfc" id="L389" title="All 4 branches covered.">                while (lastByte &gt;= '0' &amp;&amp; lastByte &lt;= '9') {</span>
<span class="fc" id="L390">                    ++len;</span>
                    // numbers are terminated by first non-numeric character.
<span class="fc" id="L392">                    lastByte = read();</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">                    if (lastByte &lt; 0) {</span>
<span class="fc" id="L394">                        break;</span>
                    }
                }
            }
        }
        // exponent part.
<span class="fc bfc" id="L400" title="All 4 branches covered.">        if (lastByte == 'e' || lastByte == 'E') {</span>
<span class="fc" id="L401">            ++len;</span>
            // numbers are terminated by first non-numeric character.
<span class="fc" id="L403">            lastByte = read();</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">            if (lastByte &gt;= 0) {</span>
                // The exponent can be explicitly prefixed with both '+'
                // and '-'.
<span class="fc bfc" id="L407" title="All 4 branches covered.">                if (lastByte == '-' || lastByte == '+') {</span>
<span class="fc" id="L408">                    ++len;</span>
                    // numbers are terminated by first non-numeric character.
<span class="fc" id="L410">                    lastByte = read();</span>
                }

<span class="pc bpc" id="L413" title="1 of 4 branches missed.">                if (lastByte &lt; '0' || '9' &lt; lastByte) {</span>
<span class="fc" id="L414">                    throw failure(startLineNo, startLinePos, len + 1, &quot;Missing exponent value&quot;);</span>
                }

<span class="fc bfc" id="L417" title="All 4 branches covered.">                while (lastByte &gt;= '0' &amp;&amp; lastByte &lt;= '9') {</span>
<span class="fc" id="L418">                    ++len;</span>
                    // numbers are terminated by first non-numeric character.
<span class="fc" id="L420">                    lastByte = read();</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">                    if (lastByte &lt; 0) {</span>
<span class="fc" id="L422">                        break;</span>
                    }
                }
            } else {
<span class="fc" id="L426">                throw failure(startLineNo, startLinePos, len,</span>
                              &quot;Unexpected end of stream after exponent indicator&quot;);
            }
        }

<span class="fc" id="L431">        return validateAfterNumber(lastByte, startOffset, startLinePos, len);</span>
    }

    private Token validateAfterNumber(int lastByte, int startOffset, int startLinePos, int len)
            throws TokenizerException {
        // A number must be terminated correctly: End of stream, space, newline
        // or a symbol that may be after a value: ':', ',' ';' '}' ')' ']', '#'.
<span class="pc bpc" id="L438" title="5 of 24 branches missed.">        if (lastByte &lt; 0 || lastByte == ' ' || lastByte == '\t' || lastByte == '\n' || lastByte == '\r' ||</span>
            lastByte == Token.kKeyValueSep ||
            lastByte == Token.kMessageEnd || lastByte == Token.kListEnd || lastByte == Token.kParamsEnd ||
            lastByte == Token.kLineSep1 || lastByte == Token.kLineSep2 || lastByte == Token.kShellComment) {
<span class="fc bfc" id="L442" title="All 2 branches covered.">            if (Token.kSymbols.indexOf(lastByte) &gt;= 0) {</span>
<span class="fc" id="L443">                unread();</span>
            }
<span class="fc" id="L445">            return token(startOffset, len, startLinePos);</span>
        } else {
            // This is safe since line breaks are valid.
<span class="fc" id="L448">            ++len;</span>
<span class="fc" id="L449">            Token token = token(startOffset, len, startLinePos);</span>
<span class="fc" id="L450">            throw failure(token,</span>
                          &quot;Invalid termination of number: '%s'&quot;,
<span class="fc" id="L452">                          Strings.escape(token.asString()));</span>
        }

    }

    private Token nextIdentifier() throws TokenizerException {
<span class="fc" id="L458">        int startOffset = readOffset;</span>
<span class="fc" id="L459">        int startLinePos = linePos;</span>
<span class="fc" id="L460">        int startLineNo = lineNo;</span>

<span class="fc" id="L462">        int len = 1, r;</span>
<span class="fc" id="L463">        boolean dot = false;</span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">        while ((r = read()) != -1) {</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">            if (r == '.') {</span>
<span class="fc" id="L466">                ++len;</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">                if (dot) {</span>
<span class="fc" id="L468">                    throw failure(startLineNo, startLinePos, len,</span>
                                  &quot;Identifier with double '.'&quot;);
                }
<span class="fc" id="L471">                dot = true;</span>
<span class="fc" id="L472">                continue;</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">            } else if (dot) {</span>
<span class="pc bpc" id="L474" title="5 of 10 branches missed.">                if (!(r == '_' ||</span>
                      (r &gt;= 'a' &amp;&amp; r &lt;= 'z') ||
                      (r &gt;= 'A' &amp;&amp; r &lt;= 'Z'))) {
<span class="pc bpc" id="L477" title="1 of 4 branches missed.">                    if (r &gt;= '0' &amp;&amp; r &lt;= '9') {</span>
<span class="fc" id="L478">                        throw failure(startLineNo, startLinePos, len + 1,</span>
                                     &quot;Identifier part starting with digit '&quot; + ((char) r) + &quot;'&quot;);
                    } else {
<span class="fc" id="L481">                        throw failure(startLineNo, startLinePos, len,</span>
                                      &quot;Identifier with trailing '.'&quot;);
                    }
                }
<span class="fc" id="L485">                ++len;</span>
<span class="fc" id="L486">                dot = false;</span>
<span class="fc" id="L487">                continue;</span>
<span class="fc bfc" id="L488" title="All 14 branches covered.">            } else if (r == '_' ||</span>
                       (r &gt;= '0' &amp;&amp; r &lt;= '9') ||
                       (r &gt;= 'a' &amp;&amp; r &lt;= 'z') ||
                       (r &gt;= 'A' &amp;&amp; r &lt;= 'Z')) {
<span class="fc" id="L492">                ++len;</span>
<span class="fc" id="L493">                continue;</span>
            }

<span class="fc" id="L496">            unread();</span>
<span class="fc" id="L497">            break;</span>
        }

<span class="pc bpc" id="L500" title="2 of 12 branches missed.">        if (r == -1 || r == ' ' || r == '\t' || r == '\n' || r == '\r' || Token.kSymbols.indexOf(r) &gt;= 0) {</span>
<span class="fc" id="L501">            return token(startOffset, len, startLinePos);</span>
        } else {
<span class="fc" id="L503">            throw failure(startLineNo, startLinePos, len,</span>
<span class="fc" id="L504">                          &quot;Wrongly terminated identifier: '%s'&quot;, escapeChar(r));</span>
        }
    }

    /**
     * Get the full non-delimited line content of the 1-indexed line.
     *
     * @param theLine The nine number.
     * @return The line string content.
     */
    @Nonnull
    public String getLine(final int theLine) {
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">        if (theLine &lt; 1) {</span>
<span class="nc" id="L517">            throw new IllegalArgumentException(theLine + &quot; is not a valid line number. Must be 1 .. N&quot;);</span>
        }
<span class="fc" id="L519">        int originalReadOffset = readOffset;</span>
<span class="fc" id="L520">        int originalLineNo = lineNo;</span>
<span class="fc" id="L521">        int originalLinePos = linePos;</span>

        // reset read position.
<span class="fc" id="L524">        readOffset = -1;</span>
<span class="fc" id="L525">        lineNo = 1;</span>
<span class="fc" id="L526">        linePos = 0;</span>

        try {
<span class="fc" id="L529">            int line = theLine;</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">            while (--line &gt; 0) {</span>
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">                if (!IOUtils.skipUntil(this, (byte) '\n')) {</span>
<span class="nc" id="L532">                    throw new IOException(&quot;No such line &quot; + theLine);</span>
                }
            }
<span class="fc" id="L535">            return IOUtils.readString(this, &quot;\n&quot;);</span>
<span class="nc" id="L536">        } catch (IOException e) {</span>
<span class="nc" id="L537">            throw new UncheckedIOException(e);</span>
        } finally {
<span class="pc" id="L539">            readOffset = originalReadOffset;</span>
<span class="pc" id="L540">            lineNo = originalLineNo;</span>
<span class="pc" id="L541">            linePos = originalLinePos;</span>
        }
    }

    /**
     * Read the 'content' of encoded binary. This does not parse the
     * binary, just read out from the buffer the string representing the
     * binary data, as delimited by the requested 'end' char.
     *
     * @param end The char that ends the binary content.
     * @return The string encoded string representation.
     * @throws TokenizerException On illegal content.
     */
    public String readBinary(char end) throws IOException {
<span class="fc" id="L555">        int startOffset = readOffset + 1;</span>
<span class="fc" id="L556">        int startLinePos = linePos;</span>
<span class="fc" id="L557">        int startLineNo = lineNo;</span>

        int r;
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">        while ((r = read()) != -1) {</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">            if (r == end) {</span>
<span class="fc" id="L562">                return new Slice(buffer, startOffset, readOffset - startOffset).asString();</span>
<span class="pc bpc" id="L563" title="4 of 8 branches missed.">            } else if (r == ' ' || r == '\t' || r == '\n' || r == '\r') {</span>
<span class="nc" id="L564">                throw failure(startLineNo, startLinePos, linePos - startLinePos + 1, &quot;Illegal char '%s' in binary&quot;, escapeChar(r));</span>
            }
        }

        // throw in with the old start.
<span class="nc" id="L569">        throw failure(startLineNo, startLinePos, linePos - startLinePos + 1, &quot;unexpected end of stream in binary&quot;);</span>
    }

    @Nonnull
    public TokenizerException failure(Token token, String message, Object... params) {
<span class="fc" id="L574">        return failure(token.getLineNo(),</span>
<span class="fc" id="L575">                       token.getLinePos(),</span>
<span class="fc" id="L576">                       token.length(),</span>
                       message, params);
    }

    @Nonnull
    protected TokenizerException failure(int startLineNo,
                                         int startLinePos,
                                         int length,
                                         String format,
                                         Object... params) {
<span class="fc" id="L586">        return failure(format, params).setLineNo(startLineNo)</span>
<span class="fc" id="L587">                                      .setLinePos(startLinePos)</span>
<span class="fc" id="L588">                                      .setLine(getLine(startLineNo))</span>
<span class="fc" id="L589">                                      .setLength(length);</span>
    }

    @Nonnull
    protected TokenizerException failure(Throwable cause,
                                         int startLineNo,
                                         int startLinePos,
                                         int length,
                                         String message,
                                         Object... params) {
<span class="nc" id="L599">        return failure(startLineNo, startLinePos, length, message, params).initCause(cause);</span>
    }

    @Nonnull
    protected TokenizerException failure(String format, Object ... params) {
<span class="fc" id="L604">        return new TokenizerException(format, params);</span>
    }

    @Nonnull
    protected Token token(int off, int len, int linePos) {
<span class="fc" id="L609">        return token(off, len, lineNo, linePos);</span>
    }

    @Nonnull
    public Token token(int off, int len, int lineNo, int linePos) {
<span class="fc" id="L614">        return new Token(buffer, off, len, lineNo, linePos);</span>
    }

    private static String escapeChar(int c) {
<span class="fc" id="L618">        return Strings.escape(new String(new char[]{(char) c}));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>