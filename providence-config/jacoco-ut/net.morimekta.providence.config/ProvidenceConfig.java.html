<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProvidenceConfig.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Providence Utils : Config</a> &gt; <a href="index.source.html" class="el_package">net.morimekta.providence.config</a> &gt; <span class="el_source">ProvidenceConfig.java</span></div><h1>ProvidenceConfig.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016,2017 Providence Authors
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package net.morimekta.providence.config;

import net.morimekta.config.IncompatibleValueException;
import net.morimekta.config.KeyNotFoundException;
import net.morimekta.providence.PEnumValue;
import net.morimekta.providence.PMessage;
import net.morimekta.providence.PMessageBuilder;
import net.morimekta.providence.PType;
import net.morimekta.providence.descriptor.PDescriptor;
import net.morimekta.providence.descriptor.PEnumDescriptor;
import net.morimekta.providence.descriptor.PField;
import net.morimekta.providence.descriptor.PList;
import net.morimekta.providence.descriptor.PMap;
import net.morimekta.providence.descriptor.PMessageDescriptor;
import net.morimekta.providence.descriptor.PSet;
import net.morimekta.providence.serializer.pretty.Token;
import net.morimekta.providence.serializer.pretty.Tokenizer;
import net.morimekta.providence.serializer.pretty.TokenizerException;
import net.morimekta.providence.util.TypeRegistry;
import net.morimekta.util.Binary;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableSet;

import javax.annotation.Nonnull;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import static net.morimekta.config.util.ConfigUtil.asBoolean;
import static net.morimekta.config.util.ConfigUtil.asDouble;
import static net.morimekta.config.util.ConfigUtil.asInteger;
import static net.morimekta.config.util.ConfigUtil.asLong;
import static net.morimekta.config.util.ConfigUtil.asString;

/**
 * Providence config loader. This loads providence configs.
 */
public class ProvidenceConfig {
    /**
     * Make a non-strict config instance.
     *
     * @param registry The type registry used to find message and enum types.
     */
    public ProvidenceConfig(TypeRegistry registry) {
<span class="fc" id="L82">        this(registry, false);</span>
<span class="fc" id="L83">    }</span>

    /**
     * Make a config instance.
     *
     * @param registry The type registry used to find message and enum types.
     * @param strict If the config should be parsed strictly.
     */
<span class="fc" id="L91">    public ProvidenceConfig(TypeRegistry registry, boolean strict) {</span>
<span class="fc" id="L92">        this.registry = registry;</span>
<span class="fc" id="L93">        this.loaded = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L94">        this.parents = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L95">        this.reverseDependencies = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L96">        this.strict = strict;</span>
<span class="fc" id="L97">    }</span>

    /**
     * Load providence config from the given file.
     *
     * @param file The file to load.
     * @param &lt;M&gt; The message type.
     * @param &lt;F&gt; The message field type.
     * @return The parsed and merged config.
     * @throws IOException If the file could not be read.
     * @throws TokenizerException If the file could not be parsed.
     */
    public &lt;M extends PMessage&lt;M, F&gt;, F extends PField&gt; M getConfig(File file) throws IOException {
<span class="fc" id="L110">        Supplier&lt;M&gt; supplier = getSupplier(file);</span>
<span class="fc" id="L111">        return supplier.get();</span>
    }

    /**
     * Load providence config from the given file.
     *
     * @param file The file to load.
     * @param descriptor The config type descriptor.
     * @param &lt;M&gt; The message type.
     * @param &lt;F&gt; The message field type.
     * @return The parsed and merged config.
     * @throws IOException If the file could not be read.
     * @throws TokenizerException If the file could not be parsed.
     */
    public &lt;M extends PMessage&lt;M, F&gt;, F extends PField&gt; M getConfig(File file, PMessageDescriptor&lt;M,F&gt; descriptor) throws IOException {
<span class="fc" id="L126">        return getSupplier(file, descriptor).get();</span>
    }

    /**
     * Load providence config from the given file.
     *
     * @param file The file to load.
     * @param &lt;M&gt; The message type.
     * @param &lt;F&gt; The message field type.
     * @return Supplier for the parsed and merged config.
     * @throws IOException If the file could not be read.
     * @throws TokenizerException If the file could not be parsed.
     */
    public synchronized &lt;M extends PMessage&lt;M, F&gt;, F extends PField&gt; Supplier&lt;M&gt; getSupplier(File file) throws IOException {
        try {
<span class="fc" id="L141">            AtomicReference&lt;M&gt; reference = loadRecursively(resolveFile(null, file.getPath()));</span>
<span class="fc" id="L142">            return reference::get;</span>
<span class="nc" id="L143">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L144">            throw new TokenizerException(e.getMessage(), e).setFile(file.getName());</span>
        }
    }

    /**
     * Load providence config from the given file, and with a defined parent
     * config. The parent config comes from a supplier, so does not need to
     * be a providence config per se.
     *
     * The loaded config will &lt;b&gt;not&lt;/b&gt; be updated when the parent config is
     * updated, as there is no known &quot;upward&quot; dependency. Therefore this should
     * only be used for non-changing config, and for top-level config that does
     * not depend on listening to upstream config changes.
     *
     * @param file The file to load.
     * @param parent The parent message for the config to inherit.
     * @param &lt;M&gt; The message type.
     * @param &lt;F&gt; The message field type.
     * @return Supplier for the parsed and merged config.
     * @throws IOException If the file could not be read.
     * @throws TokenizerException If the file could not be parsed.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public synchronized &lt;M extends PMessage&lt;M, F&gt;, F extends PField&gt; Supplier&lt;M&gt; getSupplierWithParent(File file, Supplier&lt;M&gt; parent) throws IOException {
        try {
<span class="fc" id="L169">            File config = resolveFile(null, file.getPath());</span>
<span class="fc" id="L170">            String path = config.getCanonicalFile().getAbsolutePath();</span>

            // It is assumed that if the parent is already set, it is the same.
<span class="fc" id="L173">            parents.computeIfAbsent(path, (name) -&gt; (Supplier) parent);</span>
<span class="fc" id="L174">            AtomicReference&lt;M&gt; reference = loadRecursively(config);</span>
<span class="fc" id="L175">            return reference::get;</span>
<span class="nc" id="L176">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L177">            throw new TokenizerException(e.getMessage(), e).setFile(file.getName());</span>
        }
    }

    /**
     * Load providence config from the given file, and with a defined parent
     * config. The parent config must come from an already loaded config file.
     *
     * @param configFile The file to load.
     * @param parentFile The parent config file.
     * @param &lt;M&gt; The message type.
     * @param &lt;F&gt; The message field type.
     * @return Supplier for the parsed and merged config.
     * @throws IOException If the file could not be read.
     * @throws TokenizerException If the file could not be parsed.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public synchronized &lt;M extends PMessage&lt;M, F&gt;, F extends PField&gt; Supplier&lt;M&gt; getSupplierWithParent(File configFile, File parentFile) throws IOException {
<span class="fc" id="L195">        return getSupplierWithParent(configFile, parentFile, null);</span>
    }

    /**
     * Load providence config from the given file, and with a defined parent
     * config. The parent config must come from an already loaded config file.
     *
     * @param configFile The file to load.
     * @param parentFile The parent config file.
     * @param descriptor The config type descriptor.
     * @param &lt;M&gt; The message type.
     * @param &lt;F&gt; The message field type.
     * @return Supplier for the parsed and merged config.
     * @throws IOException If the file could not be read.
     * @throws TokenizerException If the file could not be parsed.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public synchronized &lt;M extends PMessage&lt;M, F&gt;, F extends PField&gt; Supplier&lt;M&gt; getSupplierWithParent(File configFile, File parentFile, PMessageDescriptor&lt;M, F&gt; descriptor) throws IOException {
        try {
<span class="fc" id="L214">            String configPath = resolveFile(null, configFile.getPath()).getCanonicalFile().getAbsolutePath();</span>
<span class="fc" id="L215">            String parentPath = resolveFile(null, parentFile.getPath()).getCanonicalFile().getAbsolutePath();</span>

<span class="fc" id="L217">            AtomicReference&lt;M&gt; parent = (AtomicReference) loaded.get(parentPath);</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">            if (parent == null) {</span>
<span class="nc" id="L219">                throw new TokenizerException(&quot;Parent file &quot; + parentFile.getName() + &quot; is not loaded.&quot;)</span>
<span class="nc" id="L220">                        .setFile(configFile.getName());</span>
            }
<span class="pc bpc" id="L222" title="1 of 4 branches missed.">            if (descriptor != null &amp;&amp; !parent.get().descriptor().equals(descriptor)) {</span>
<span class="nc" id="L223">                throw new TokenizerException(</span>
<span class="nc" id="L224">                        String.format(</span>
                                Locale.ENGLISH,
                                &quot;Incompatible message type: Expected %s, got %s&quot;,
<span class="nc" id="L227">                                descriptor.getQualifiedName(),</span>
<span class="nc" id="L228">                                parent.get().descriptor().getQualifiedName()))</span>
<span class="nc" id="L229">                        .setFile(configFile.getPath());</span>
            }

<span class="fc" id="L232">            Supplier&lt;M&gt; supplier = getSupplierWithParent(configFile, parent::get);</span>

<span class="pc bpc" id="L234" title="1 of 4 branches missed.">            if (descriptor != null &amp;&amp; !supplier.get().descriptor().equals(descriptor)) {</span>
<span class="nc" id="L235">                throw new TokenizerException(</span>
<span class="nc" id="L236">                        String.format(</span>
                                Locale.ENGLISH,
                                &quot;Incompatible message type: Expected %s, got %s&quot;,
<span class="nc" id="L239">                                descriptor.getQualifiedName(),</span>
<span class="nc" id="L240">                                supplier.get().descriptor().getQualifiedName()))</span>
<span class="nc" id="L241">                        .setFile(configFile.getPath());</span>
            }

<span class="fc" id="L244">            getReverseDeps(parentPath).add(configPath);</span>

<span class="fc" id="L246">            return supplier;</span>
<span class="nc" id="L247">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L248">            throw new TokenizerException(e.getMessage(), e).setFile(configFile.getName());</span>
        }
    }
    /**
     * Load providence config from the given file.
     *
     * @param file The file to load.
     * @param descriptor Descriptor of type to load.
     * @param &lt;M&gt; The message type.
     * @param &lt;F&gt; The message field type.
     * @return Supplier for the parsed and merged config.
     * @throws IOException If the file could not be read.
     * @throws TokenizerException If the file could not be parsed.
     */
    public &lt;M extends PMessage&lt;M, F&gt;, F extends PField&gt; Supplier&lt;M&gt; getSupplier(File file, PMessageDescriptor&lt;M,F&gt; descriptor) throws IOException {
        try {
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">            if (descriptor != null) {</span>
<span class="fc" id="L265">                registry.registerRecursively(descriptor);</span>
            }
<span class="fc" id="L267">            Supplier&lt;M&gt; supplier = getSupplier(file);</span>
<span class="pc bpc" id="L268" title="2 of 4 branches missed.">            if (descriptor != null &amp;&amp; !supplier.get().descriptor().equals(descriptor)) {</span>
<span class="nc" id="L269">                throw new TokenizerException(</span>
<span class="nc" id="L270">                        String.format(</span>
                                Locale.ENGLISH,
                                &quot;Incompatible message type: Expected %s, got %s&quot;,
<span class="nc" id="L273">                                descriptor.getQualifiedName(),</span>
<span class="nc" id="L274">                                supplier.get().descriptor().getQualifiedName()))</span>
<span class="nc" id="L275">                        .setFile(file.getPath());</span>
            }

<span class="fc" id="L278">            return supplier;</span>
<span class="nc" id="L279">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L280">            throw new TokenizerException(e.getMessage()).setFile(file.getName());</span>
        }
    }

    /**
     * Trigger reloading of the given file, and run recursively &lt;i&gt;up&lt;/i&gt; through dependencies.
     *
     * @param file The file that may need to be reloaded.
     * @throws IOException If reloading failed for any reason.
     */
    public void reload(File file) throws IOException {
<span class="fc" id="L291">        String canonicalPath = file.getCanonicalFile()</span>
<span class="fc" id="L292">                                   .getAbsolutePath();</span>

<span class="fc" id="L294">        AtomicReference&lt;PMessage&gt; reference = loaded.get(canonicalPath);</span>
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">        if (reference == null) {</span>
<span class="nc" id="L296">            return;</span>
        }
<span class="fc" id="L298">        Set&lt;String&gt; dependencies = new TreeSet&lt;&gt;(getReverseDeps(canonicalPath));</span>

        try {
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L302">            PMessage reloaded = parseConfigRecursively(file, new String[]{canonicalPath});</span>
<span class="fc" id="L303">            if (reference.get()</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">                         .equals(reloaded)) {</span>
<span class="nc" id="L305">                return;</span>
            }

<span class="fc" id="L308">            reference.set(reloaded);</span>

<span class="fc bfc" id="L310" title="All 2 branches covered.">            for (String dep : dependencies) {</span>
<span class="fc" id="L311">                reload(new File(dep));</span>
<span class="fc" id="L312">            }</span>
<span class="nc" id="L313">        } catch (IOException e) {</span>
            // TODO: Reinstate the old value if we failed to reload it. Also
            // reinstate the old value if any of the dependent files failed
            // to load. The reason they failed could easily be that this
            // file was no longer compatible.
<span class="nc" id="L318">            throw new IOException(e.getMessage(), e);</span>
<span class="fc" id="L319">        }</span>
<span class="fc" id="L320">    }</span>

    /**
     * Resolve a file path within the source roots.
     *
     * @param ref A file or directory reference
     * @param path The file reference to resolve.
     * @return The resolved file.
     * @throws FileNotFoundException When the file is not found.
     * @throws IOException When unable to make canonical path.
     */
    @VisibleForTesting
    File resolveFile(File ref, String path) throws IOException {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (ref == null) {</span>
            // relative to PWD from initial load file path.
<span class="fc" id="L335">            File tmp = new File(path).getCanonicalFile().getAbsoluteFile();</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">            if (tmp.exists()) {</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">                if (tmp.isFile()) {</span>
<span class="fc" id="L338">                    return tmp;</span>
                }
<span class="fc" id="L340">                throw new FileNotFoundException(path + &quot; is a directory, expected file&quot;);</span>
            }
<span class="fc" id="L342">            throw new FileNotFoundException(&quot;File &quot; + path + &quot; not found&quot;);</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">        } else if (path.startsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L344">            throw new FileNotFoundException(&quot;Absolute path includes not allowed: &quot; + path);</span>
        } else {
            // relative to reference file. Parent directory lookup (..) allowed.

<span class="pc bpc" id="L348" title="1 of 2 branches missed.">            if (!ref.isDirectory()) {</span>
<span class="fc" id="L349">                ref = ref.getParentFile();</span>
            }
<span class="fc" id="L351">            File tmp = new File(ref, path).getCanonicalFile()</span>
<span class="fc" id="L352">                                          .getAbsoluteFile();</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">            if (tmp.exists()) {</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">                if (tmp.isFile()) {</span>
<span class="fc" id="L355">                    return tmp;</span>
                }
<span class="fc" id="L357">                throw new FileNotFoundException(path + &quot; is a directory, expected file&quot;);</span>
            }
<span class="fc" id="L359">            throw new FileNotFoundException(&quot;Included file &quot; + path + &quot; not found&quot;);</span>
        }
    }

    private Set&lt;String&gt; getReverseDeps(String to) {
<span class="fc" id="L364">        return reverseDependencies.computeIfAbsent(to, k -&gt; new LinkedHashSet&lt;&gt;());</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;) @Nonnull
    private &lt;M extends PMessage&lt;M, F&gt;, F extends PField&gt; AtomicReference&lt;M&gt; loadRecursively(File file, String... stack)
            throws IOException {
        M result;

        try {
<span class="fc" id="L373">            file = file.getCanonicalFile()</span>
<span class="fc" id="L374">                       .getAbsoluteFile();</span>
<span class="fc" id="L375">            String filePath = file.toString();</span>

<span class="fc" id="L377">            List&lt;String&gt; stackList = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L378">            Collections.addAll(stackList, stack);</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">            if (stackList.contains(filePath)) {</span>
<span class="fc" id="L380">                stackList.add(filePath);</span>
<span class="fc" id="L381">                throw new TokenizerException(&quot;Circular includes detected: &quot; + String.join(&quot; -&gt; &quot;,</span>
<span class="fc" id="L382">                                                                                          stackList.stream()</span>
<span class="fc" id="L383">                                                                                                   .map(p -&gt; new File(p).getName())</span>
<span class="fc" id="L384">                                                                                                   .collect(Collectors.toList())));</span>
            }

<span class="fc bfc" id="L387" title="All 2 branches covered.">            if (loaded.containsKey(filePath)) {</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">                if (stack.length &gt; 0) {</span>
<span class="fc" id="L389">                    getReverseDeps(filePath).add(stack[stack.length - 1]);</span>
                }

<span class="fc" id="L392">                return (AtomicReference) loaded.get(filePath);</span>
            }

<span class="fc" id="L395">            stackList.add(filePath);</span>

<span class="fc" id="L397">            result = parseConfigRecursively(file, stackList.toArray(new String[stackList.size()]));</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">            if (result == null) {</span>
<span class="fc" id="L399">                return new AtomicReference&lt;&gt;();</span>
            }

<span class="fc" id="L402">            stackList.add(filePath);</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">            if (stack.length &gt; 0) {</span>
<span class="fc" id="L404">                getReverseDeps(filePath).add(stack[stack.length - 1]);</span>
            }

<span class="fc" id="L407">            AtomicReference ref = loaded.get(filePath);</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">            if (ref == null) {</span>
<span class="fc" id="L409">                ref = new AtomicReference(result);</span>
<span class="fc" id="L410">                loaded.put(filePath, ref);</span>
            } else {
<span class="nc" id="L412">                ref.set(result);</span>
            }

<span class="fc" id="L415">            return ref;</span>
<span class="fc" id="L416">        } catch (TokenizerException e) {</span>
<span class="fc" id="L417">            throw new TokenizerException(e, file);</span>
        }
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;M extends PMessage&lt;M, F&gt;, F extends PField&gt; M parseConfigRecursively(File file,
                                                                                  String[] stack) throws IOException {
        Tokenizer tokenizer;
<span class="pc" id="L425">        try (BufferedInputStream in = new BufferedInputStream(new FileInputStream(file))) {</span>
            // Non-enclosed content, meaning we should read the whole file immediately.
<span class="fc" id="L427">            tokenizer = new Tokenizer(in, false);</span>
<span class="pc bpc" id="L428" title="6 of 8 branches missed.">        }</span>

<span class="fc" id="L430">        ProvidenceConfigContext context = new ProvidenceConfigContext();</span>

<span class="fc" id="L432">        Stage lastStage = Stage.INCLUDES;</span>
<span class="fc" id="L433">        M result = null;</span>

<span class="fc" id="L435">        Token token = tokenizer.peek();</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">        while (token != null) {</span>
<span class="fc" id="L437">            tokenizer.next();</span>

<span class="pc bpc" id="L439" title="1 of 2 branches missed.">            if (lastStage == Stage.MESSAGE) {</span>
<span class="nc" id="L440">                throw new TokenizerException(token, &quot;Unexpected token '&quot; + token.asString() + &quot;', expected end of file.&quot;)</span>
<span class="nc" id="L441">                        .setLine(tokenizer.getLine(token.getLineNo()));</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">            } else if (INCLUDE.equals(token.asString())) {</span>
                // if include &amp;&amp; stage == INCLUDES --&gt; INCLUDES
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">                if (lastStage != Stage.INCLUDES) {</span>
<span class="nc" id="L445">                    throw new TokenizerException(token, &quot;Include added after defines or message. Only one def block allowed.&quot;)</span>
<span class="nc" id="L446">                            .setLine(tokenizer.getLine(token.getLineNo()));</span>
                }
<span class="fc" id="L448">                token = tokenizer.expectLiteral(&quot;file to be included&quot;);</span>
<span class="fc" id="L449">                String includedFilePath = token.decodeLiteral(strict);</span>
                PMessage included;
                File includedFile;
                try {
<span class="fc" id="L453">                    includedFile = resolveFile(file, includedFilePath);</span>
<span class="fc" id="L454">                    included = loadRecursively(includedFile, stack).get();</span>
<span class="fc" id="L455">                } catch (FileNotFoundException e) {</span>
<span class="fc" id="L456">                    throw new TokenizerException(token, &quot;Included file \&quot;%s\&quot; not found.&quot;, includedFilePath)</span>
<span class="fc" id="L457">                            .setLine(tokenizer.getLine(token.getLineNo()));</span>
<span class="fc" id="L458">                }</span>
<span class="fc" id="L459">                token = tokenizer.expectIdentifier(&quot;the token 'as'&quot;);</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">                if (!AS.equals(token.asString())) {</span>
<span class="fc" id="L461">                    throw new TokenizerException(token, &quot;Expected token 'as' after included file \&quot;%s\&quot;.&quot;, includedFilePath)</span>
<span class="fc" id="L462">                            .setLine(tokenizer.getLine(token.getLineNo()));</span>
                }
<span class="fc" id="L464">                token = tokenizer.expectIdentifier(&quot;Include alias&quot;);</span>
<span class="fc" id="L465">                String alias = token.asString();</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">                if (RESERVED_WORDS.contains(alias)) {</span>
<span class="fc" id="L467">                    throw new TokenizerException(token, &quot;Alias \&quot;%s\&quot; is a reserved word.&quot;, alias)</span>
<span class="fc" id="L468">                            .setLine(tokenizer.getLine(token.getLineNo()));</span>
                }
<span class="fc bfc" id="L470" title="All 2 branches covered.">                if (context.containsReference(alias)) {</span>
<span class="fc" id="L471">                    throw new TokenizerException(token, &quot;Alias \&quot;%s\&quot; is already used.&quot;, alias)</span>
<span class="fc" id="L472">                            .setLine(tokenizer.getLine(token.getLineNo()));</span>
                }
<span class="fc" id="L474">                context.setInclude(alias, included);</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">            } else if (DEF.equals(token.asString())) {</span>
                // if params &amp;&amp; stage == DEF --&gt; DEF
<span class="fc bfc" id="L477" title="All 2 branches covered.">                if (lastStage != Stage.INCLUDES) {</span>
<span class="fc" id="L478">                    throw new TokenizerException(token, &quot;Defines already complete or passed.&quot;).setLine(</span>
<span class="fc" id="L479">                            tokenizer.getLine(token.getLineNo()));</span>
                }
<span class="fc" id="L481">                lastStage = Stage.DEFINES;</span>
<span class="fc" id="L482">                parseDefinitions(context, tokenizer);</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">            } else if (token.isQualifiedIdentifier()) {</span>
                // if a.b (type identifier) --&gt; MESSAGE
<span class="fc" id="L485">                lastStage = Stage.MESSAGE;</span>
                PMessageDescriptor&lt;M, F&gt; descriptor;
                try {
<span class="fc" id="L488">                    descriptor = (PMessageDescriptor) registry.getDeclaredType(token.asString());</span>
<span class="fc" id="L489">                } catch (IllegalArgumentException e) {</span>
                    // Unknown declared type. Fail if:
                    // - strict mode, all files must be of known types.
                    // - top of the stack. This is the config requested by the user. It should fail
                    //   even in non-strict mode.
<span class="pc bpc" id="L494" title="1 of 4 branches missed.">                    if (strict || stack.length == 1) {</span>
<span class="fc" id="L495">                        throw new TokenizerException(token, &quot;Unknown declared type: %s&quot;, token.asString()).setLine(</span>
<span class="fc" id="L496">                                tokenizer.getLine(token.getLineNo()));</span>
                    }
<span class="fc" id="L498">                    return null;</span>
<span class="fc" id="L499">                }</span>
<span class="fc" id="L500">                result = parseConfigMessage(tokenizer, context, descriptor.builder(), file);</span>
<span class="fc" id="L501">            } else {</span>
<span class="fc" id="L502">                throw new TokenizerException(token,</span>
<span class="fc" id="L503">                                             &quot;Unexpected token '&quot; + token.asString() +</span>
                                             &quot;'. Expected include, defines or message type&quot;)
<span class="fc" id="L505">                        .setLine(tokenizer.getLine(token.getLineNo()));</span>
            }

<span class="fc" id="L508">            token = tokenizer.peek();</span>
        }

<span class="fc bfc" id="L511" title="All 2 branches covered.">        if (result == null) {</span>
<span class="fc" id="L512">            throw new TokenizerException(&quot;No message in config: &quot; + file.getName());</span>
        }

<span class="fc" id="L515">        return result;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private void parseDefinitions(ProvidenceConfigContext context, Tokenizer tokenizer) throws IOException {
<span class="fc" id="L520">        tokenizer.expectSymbol(&quot;defines start&quot;, Token.kMessageStart);</span>
<span class="fc" id="L521">        Token token = tokenizer.expect(&quot;define or end&quot;);</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">        while (!token.isSymbol(Token.kMessageEnd)) {</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">            if (!token.isIdentifier()) {</span>
<span class="fc" id="L524">                throw new TokenizerException(token, &quot;Reference name '%s' is not valid.&quot;, token.asString())</span>
<span class="fc" id="L525">                        .setLine(tokenizer.getLine(token.getLineNo()));</span>
            }
<span class="fc" id="L527">            String name = context.initReference(token, tokenizer);</span>
<span class="fc" id="L528">            tokenizer.expectSymbol(&quot;def value sep&quot;, Token.kFieldValueSep);</span>
<span class="fc" id="L529">            token = tokenizer.expect(&quot;def value&quot;);</span>

<span class="fc bfc" id="L531" title="All 2 branches covered.">            if (token.isReal()) {</span>
<span class="fc" id="L532">                context.setReference(name, Double.parseDouble(token.asString()));</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">            } else if (token.isInteger()) {</span>
<span class="fc" id="L534">                context.setReference(name, Long.parseLong(token.asString()));</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">            } else if (token.isStringLiteral()) {</span>
<span class="fc" id="L536">                context.setReference(name, token.decodeLiteral(strict));</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">            } else if (TRUE.equalsIgnoreCase(token.asString())) {</span>
<span class="fc" id="L538">                context.setReference(name, true);</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">            } else if (FALSE.equalsIgnoreCase(token.asString())) {</span>
<span class="nc" id="L540">                context.setReference(name, false);</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">            } else if (Token.B64.equals(token.asString())) {</span>
<span class="nc" id="L542">                tokenizer.expectSymbol(&quot;binary data enclosing start&quot;, Token.kParamsStart);</span>
<span class="nc" id="L543">                context.setReference(name, Binary.fromBase64(tokenizer.readBinary(Token.kParamsEnd)));</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">            } else if (Token.HEX.equals(token.asString())) {</span>
<span class="fc" id="L545">                tokenizer.expectSymbol(&quot;binary data enclosing start&quot;, Token.kParamsStart);</span>
<span class="fc" id="L546">                context.setReference(name, Binary.fromHexString(tokenizer.readBinary(Token.kParamsEnd)));</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">            } else if (token.isDoubleQualifiedIdentifier()) {</span>
                // this may be an enum reference, must be
                // - package.EnumType.IDENTIFIER

<span class="fc" id="L551">                String id = token.asString();</span>
<span class="fc" id="L552">                int l = id.lastIndexOf(Token.kIdentifierSep);</span>
                try {
                    // These extra casts needs to be there, otherwise we'd get this error:
                    // incompatible types: inference variable T has incompatible upper bounds
                    // net.morimekta.providence.descriptor.PDeclaredDescriptor&lt;net.morimekta.providence.descriptor.PEnumDescriptor&gt;,
                    // net.morimekta.providence.descriptor.PEnumDescriptor
                    // TODO: Figure out a way to fix the generic cast.
<span class="fc" id="L559">                    PEnumDescriptor ed = (PEnumDescriptor) (Object) registry.getDeclaredType(id.substring(0, l));</span>
<span class="fc" id="L560">                    PEnumValue val = ed.findByName(id.substring(l + 1));</span>
<span class="pc bpc" id="L561" title="3 of 4 branches missed.">                    if (val == null &amp;&amp; strict) {</span>
<span class="nc" id="L562">                        throw new TokenizerException(token, &quot;Unknown %s value: %s&quot;, id.substring(0, l), id.substring(l + 1))</span>
<span class="nc" id="L563">                                .setLine(tokenizer.getLine(token.getLineNo()));</span>
                    }
                    // Note that unknown enum value results in null. Therefore we don't catch null values here.
<span class="fc" id="L566">                    context.setReference(name, val);</span>
<span class="fc" id="L567">                } catch (IllegalArgumentException e) {</span>
                    // No such declared type.
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">                    if (strict) {</span>
<span class="fc" id="L570">                        throw new TokenizerException(token, &quot;Unknown enum identifier: %s&quot;, id.substring(0, l))</span>
<span class="fc" id="L571">                                .setLine(tokenizer.getLine(token.getLineNo()));</span>
                    }
<span class="nc" id="L573">                } catch (ClassCastException e) {</span>
                    // Not an enum.
<span class="nc" id="L575">                    throw new TokenizerException(token, &quot;Identifier &quot; + id + &quot; does not reference an enum, from &quot; + token.asString())</span>
<span class="nc" id="L576">                            .setLine(tokenizer.getLine(token.getLineNo()));</span>
<span class="pc" id="L577">                }</span>
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">            } else if (token.isQualifiedIdentifier()) {</span>
                // Message type.
                PMessageDescriptor descriptor;
                try {
<span class="fc" id="L582">                    descriptor = (PMessageDescriptor) (Object) registry.getDeclaredType(token.asString());</span>
<span class="nc" id="L583">                } catch (IllegalArgumentException e) {</span>
                    // Unknown declared type. Fail if:
                    // - strict mode: all types must be known.
<span class="nc bnc" id="L586" title="All 2 branches missed.">                    if (strict) {</span>
<span class="nc" id="L587">                        throw new TokenizerException(token, &quot;Unknown declared type: %s&quot;, token.asString()).setLine(</span>
<span class="nc" id="L588">                                tokenizer.getLine(token.getLineNo()));</span>
                    }
<span class="nc" id="L590">                    continue;</span>
<span class="fc" id="L591">                }</span>
<span class="fc" id="L592">                PMessageBuilder builder = descriptor.builder();</span>
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">                if (tokenizer.expectSymbol(&quot;message start or inherits&quot;, '{', ':') == ':') {</span>
<span class="nc" id="L594">                    token = tokenizer.expect(&quot;inherits reference&quot;);</span>
<span class="nc" id="L595">                    PMessage inheritsFrom = resolve(context, token, tokenizer, descriptor);</span>
<span class="nc" id="L596">                    builder.merge(inheritsFrom);</span>
<span class="nc" id="L597">                    tokenizer.expectSymbol(&quot;message start&quot;, '{');</span>
                }

<span class="fc" id="L600">                PMessage message = parseMessage(tokenizer, context, builder);</span>
<span class="fc" id="L601">                context.setReference(name, message);</span>
<span class="fc" id="L602">            } else {</span>
<span class="nc" id="L603">                throw new TokenizerException(token, &quot;Invalid define value &quot; + token.asString())</span>
<span class="nc" id="L604">                        .setLine(tokenizer.getLine(token.getLineNo()));</span>
            }

<span class="fc" id="L607">            token = tokenizer.expect(&quot;next define or end&quot;);</span>
<span class="fc" id="L608">        }</span>
<span class="fc" id="L609">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;M extends PMessage&lt;M, F&gt;, F extends PField&gt; M parseConfigMessage(Tokenizer tokenizer,
                                                                              ProvidenceConfigContext context,
                                                                              PMessageBuilder&lt;M, F&gt; builder,
                                                                              File file)
            throws IOException {
<span class="fc" id="L617">        String path = file.getCanonicalFile().getAbsolutePath();</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">        if (tokenizer.expectSymbol(&quot;extension marker&quot;, Token.kKeyValueSep, Token.kMessageStart) == Token.kKeyValueSep) {</span>
<span class="fc" id="L619">            Token token = tokenizer.expect(&quot;extension object&quot;);</span>

<span class="pc bpc" id="L621" title="1 of 2 branches missed.">            if (parents.containsKey(path)) {</span>
<span class="nc" id="L622">                throw new TokenizerException(token, &quot;Config in '&quot; + file.getName() + &quot;' has both defined parent and inherits from&quot;)</span>
<span class="nc" id="L623">                        .setLine(tokenizer.getLine(token.getLineNo()))</span>
<span class="nc" id="L624">                        .setFile(file.getName());</span>
            }

<span class="pc bpc" id="L627" title="1 of 2 branches missed.">            if (token.isReferenceIdentifier()) {</span>
                try {
<span class="fc" id="L629">                    builder.merge(resolve(context, token, tokenizer, builder.descriptor()));</span>
<span class="nc" id="L630">                } catch (ClassCastException e) {</span>
<span class="nc" id="L631">                    throw new TokenizerException(token, &quot;Config type mismatch, expected  &quot;)</span>
<span class="nc" id="L632">                            .setLine(tokenizer.getLine(token.getLineNo()));</span>
<span class="nc" id="L633">                } catch (KeyNotFoundException e) {</span>
<span class="nc" id="L634">                    throw new TokenizerException(token, e.getMessage())</span>
<span class="nc" id="L635">                            .setLine(tokenizer.getLine(token.getLineNo()));</span>
<span class="fc" id="L636">                }</span>
<span class="fc" id="L637">                tokenizer.expectSymbol(&quot;object begin&quot;, Token.kMessageStart);</span>
            } else {
<span class="nc" id="L639">                throw new TokenizerException(token, &quot;Unexpected token &quot; + token.asString() + &quot;, expected reference identifier&quot;)</span>
<span class="nc" id="L640">                        .setLine(tokenizer.getLine(token.getLineNo()));</span>
            }
<span class="fc bfc" id="L642" title="All 2 branches covered.">        } else if (parents.containsKey(path)) {</span>
<span class="fc" id="L643">            builder.merge((M) parents.get(path).get());</span>
        }

<span class="fc" id="L646">        return parseMessage(tokenizer, context, builder);</span>
    }

    private void consumeValue(ProvidenceConfigContext context, Tokenizer tokenizer, Token token) throws IOException {
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">        if (UNDEFINED.equals(token.asString())) {</span>
            // ignore undefined.
<span class="nc" id="L652">            return;</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">        } else if (token.isReferenceIdentifier()) {</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">            if (!tokenizer.peek().isSymbol(Token.kMessageStart)) {</span>
                // just a reference.
<span class="nc" id="L656">                return;</span>
            }
            // reference + message.
<span class="fc" id="L659">            token = tokenizer.next();</span>
        }
<span class="fc bfc" id="L661" title="All 2 branches covered.">        if (token.isSymbol(Token.kMessageStart)) {</span>
            // message or map.
<span class="fc" id="L663">            token = tokenizer.expect(&quot;map or message first entry&quot;);</span>

<span class="pc bpc" id="L665" title="2 of 4 branches missed.">            if (!token.isSymbol(Token.kMessageEnd) &amp;&amp; !token.isIdentifier()) {</span>
                // assume map.
<span class="nc bnc" id="L667" title="All 2 branches missed.">                while (!token.isSymbol(Token.kMessageEnd)) {</span>
<span class="nc bnc" id="L668" title="All 4 branches missed.">                    if (token.isIdentifier() || token.isReferenceIdentifier()) {</span>
<span class="nc" id="L669">                        throw new TokenizerException(token, &quot;Invalid map key: &quot; + token.asString())</span>
<span class="nc" id="L670">                                .setLine(tokenizer.getLine(token.getLineNo()));</span>
                    }
<span class="nc" id="L672">                    consumeValue(context, tokenizer, token);</span>
<span class="nc" id="L673">                    tokenizer.expectSymbol(&quot;key value sep.&quot;, Token.kKeyValueSep);</span>
<span class="nc" id="L674">                    consumeValue(context, tokenizer, tokenizer.expect(&quot;map value&quot;));</span>

                    // maps do *not* require separator, but allows ',' separator, and separator after last.
<span class="nc" id="L677">                    token = tokenizer.expect(&quot;map key, end or sep&quot;);</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">                    if (token.isSymbol(Token.kLineSep1)) {</span>
<span class="nc" id="L679">                        token = tokenizer.expect(&quot;map key or end&quot;);</span>
                    }
                }
            } else {
                // assume message.
<span class="fc bfc" id="L684" title="All 2 branches covered.">                while (!token.isSymbol(Token.kMessageEnd)) {</span>
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">                    if (!token.isIdentifier()) {</span>
<span class="nc" id="L686">                        throw new TokenizerException(token, &quot;Invalid field name: &quot; + token.asString())</span>
<span class="nc" id="L687">                                .setLine(tokenizer.getLine(token.getLineNo()));</span>
                    }
<span class="fc bfc" id="L689" title="All 2 branches covered.">                    if (tokenizer.peek().isSymbol(kDefineReference)) {</span>
<span class="fc" id="L690">                        tokenizer.next();</span>
<span class="pc" id="L691">                        context.setReference(</span>
<span class="nc" id="L692">                                context.initReference(</span>
<span class="fc" id="L693">                                        tokenizer.expectIdentifier(&quot;reference name&quot;), tokenizer),</span>
                                null);
                    }

<span class="pc bpc" id="L697" title="1 of 2 branches missed.">                    if (tokenizer.peek().isSymbol(Token.kMessageStart)) {</span>
                        // direct inheritance of message field.
<span class="nc" id="L699">                        consumeValue(context, tokenizer, tokenizer.next());</span>
                    } else {
<span class="fc" id="L701">                        tokenizer.expectSymbol(&quot;field value sep.&quot;, Token.kFieldValueSep);</span>
<span class="fc" id="L702">                        consumeValue(context, tokenizer, tokenizer.next());</span>
                    }
<span class="fc" id="L704">                    token = nextNotLineSep(tokenizer, &quot;message field or end&quot;);</span>
                }
            }
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">        } else if (token.isSymbol(Token.kListStart)) {</span>
<span class="nc" id="L708">            token = tokenizer.next();</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">            while (!token.isSymbol(Token.kListEnd)) {</span>
<span class="nc" id="L710">                consumeValue(context, tokenizer, token);</span>
                // lists and sets require list separator (,), and allows trailing separator.
<span class="nc bnc" id="L712" title="All 2 branches missed.">                if (tokenizer.expectSymbol(&quot;list separator or end&quot;, Token.kLineSep1, Token.kListEnd) == Token.kListEnd) {</span>
<span class="nc" id="L713">                    break;</span>
                }
<span class="nc" id="L715">                token = tokenizer.expect(&quot;list value or end&quot;);</span>
            }
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">        } else if (token.asString().equals(Token.HEX)) {</span>
<span class="nc" id="L718">            tokenizer.expectSymbol(&quot;hex body start&quot;, Token.kParamsStart);</span>
<span class="nc" id="L719">            tokenizer.readBinary(Token.kParamsEnd);</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">        } else if (!(token.isReal() ||  // number (double)</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">                     token.isInteger() ||  // number (int)</span>
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">                     token.isStringLiteral() ||  // string literal</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">                     token.isIdentifier())) {  // enum value reference.</span>
<span class="nc" id="L724">            throw new TokenizerException(token, &quot;Unknown value token '%s'&quot;, token.asString())</span>
<span class="nc" id="L725">                    .setLine(tokenizer.getLine(token.getLineNo()));</span>
        }
<span class="fc" id="L727">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;M extends PMessage&lt;M, F&gt;, F extends PField&gt; M parseMessage(Tokenizer tokenizer,
                                                                        ProvidenceConfigContext context,
                                                                        PMessageBuilder&lt;M, F&gt; builder)
            throws IOException {
<span class="fc" id="L734">        PMessageDescriptor&lt;M, F&gt; descriptor = builder.descriptor();</span>

<span class="fc" id="L736">        Token token = tokenizer.expect(&quot;object end or field&quot;);</span>
<span class="fc bfc" id="L737" title="All 2 branches covered.">        while (!token.isSymbol(Token.kMessageEnd)) {</span>
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">            if (!token.isIdentifier()) {</span>
<span class="nc" id="L739">                throw new TokenizerException(token, &quot;Invalid field name: &quot; + token.asString())</span>
<span class="nc" id="L740">                        .setLine(tokenizer.getLine(token.getLineNo()));</span>
            }

<span class="fc" id="L743">            F field = descriptor.findFieldByName(token.asString());</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">            if (field == null) {</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">                if (strict) {</span>
<span class="fc" id="L746">                    throw new TokenizerException(&quot;No such field &quot; + token.asString() + &quot; in &quot; + descriptor.getQualifiedName())</span>
<span class="fc" id="L747">                            .setLine(tokenizer.getLine(token.getLineNo()));</span>
                } else {
<span class="fc" id="L749">                    token = tokenizer.expect(&quot;field value sep, message start or reference start&quot;);</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">                    if (token.isSymbol(kDefineReference)) {</span>
<span class="pc" id="L751">                        context.setReference(</span>
<span class="nc" id="L752">                                context.initReference(tokenizer.expectIdentifier(&quot;reference name&quot;), tokenizer),</span>
                                null);
                        // Ignore reference.
<span class="nc" id="L755">                        token = tokenizer.expect(&quot;field value sep or message start&quot;);</span>
                    }
<span class="fc bfc" id="L757" title="All 2 branches covered.">                    if (token.isSymbol(Token.kFieldValueSep)) {</span>
<span class="fc" id="L758">                        token = tokenizer.expect(&quot;value declaration&quot;);</span>
<span class="pc bpc" id="L759" title="1 of 2 branches missed.">                    } else if (!token.isSymbol(Token.kMessageStart)) {</span>
<span class="nc" id="L760">                        throw new TokenizerException(token, &quot;Expected field-value separator or inherited message&quot;)</span>
<span class="nc" id="L761">                                .setLine(tokenizer.getLine(token.getLineNo()));</span>
                    }
                    // Non-strict will just consume unknown fields, this way
                    // we can be forward-compatible when reading config.
<span class="fc" id="L765">                    consumeValue(context, tokenizer, token);</span>
<span class="fc" id="L766">                    token = nextNotLineSep(tokenizer, &quot;field or message end&quot;);</span>
<span class="fc" id="L767">                    continue;</span>
                }
            }

<span class="fc bfc" id="L771" title="All 2 branches covered.">            if (field.getType() == PType.MESSAGE) {</span>
                // go recursive with optional
<span class="fc" id="L773">                String reference = null;</span>
<span class="fc" id="L774">                char symbol = tokenizer.expectSymbol(</span>
                        &quot;Message assigner or start&quot;,
                        Token.kFieldValueSep,
                        Token.kMessageStart,
                        kDefineReference);
<span class="fc bfc" id="L779" title="All 2 branches covered.">                if (symbol == kDefineReference) {</span>
<span class="fc" id="L780">                    reference = context.initReference(tokenizer.expectIdentifier(&quot;reference name&quot;), tokenizer);</span>
<span class="fc" id="L781">                    symbol = tokenizer.expectSymbol(&quot;Message assigner or start after &quot; + reference, Token.kFieldValueSep, Token.kMessageStart);</span>
                }

                PMessageBuilder bld;
<span class="fc bfc" id="L785" title="All 2 branches covered.">                if (symbol == Token.kFieldValueSep) {</span>
<span class="fc" id="L786">                    token = tokenizer.expect(&quot;reference or message start&quot;);</span>
<span class="fc bfc" id="L787" title="All 2 branches covered.">                    if (UNDEFINED.equals(token.asString())) {</span>
                        // unset.
<span class="fc" id="L789">                        builder.clear(field.getId());</span>
<span class="fc" id="L790">                        context.setReference(reference, null);</span>

                        // special casing this, as we don't want to duplicate the parse line below.
<span class="fc" id="L793">                        token = nextNotLineSep(tokenizer, &quot;field or message end&quot;);</span>
<span class="fc" id="L794">                        continue;</span>
                    }
                    // overwrite with new.
<span class="fc" id="L797">                    bld = ((PMessageDescriptor) field.getDescriptor()).builder();</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">                    if (token.isReferenceIdentifier()) {</span>
                        // Inherit from reference.
                        try {
<span class="fc" id="L801">                            PMessage ref = resolve(context, token, tokenizer, field.getDescriptor());</span>
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">                            if (ref != null) {</span>
<span class="fc" id="L803">                                bld.merge(ref);</span>
                            } else {
<span class="nc bnc" id="L805" title="All 2 branches missed.">                                if (tokenizer.peek().isSymbol(Token.kMessageStart)) {</span>
<span class="nc" id="L806">                                    throw new TokenizerException(token, &quot;Inherit from unknown reference %s&quot;, token.asString())</span>
<span class="nc" id="L807">                                            .setLine(tokenizer.getLine(token.getLineNo()));</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">                                } else if (strict) {</span>
<span class="nc" id="L809">                                    throw new TokenizerException(token, &quot;Unknown reference %s&quot;, token.asString())</span>
<span class="nc" id="L810">                                            .setLine(tokenizer.getLine(token.getLineNo()));</span>
                                }
                            }
<span class="nc" id="L813">                        } catch (KeyNotFoundException e) {</span>
<span class="nc" id="L814">                            throw new TokenizerException(token, &quot;Unknown inherited reference '%s'&quot;, token.asString())</span>
<span class="nc" id="L815">                                    .setLine(tokenizer.getLine(token.getLineNo()));</span>
<span class="fc" id="L816">                        }</span>

<span class="fc" id="L818">                        token = tokenizer.expect(&quot;after message reference&quot;);</span>
                        // if the following symbol is *not* message start,
                        // we assume a new field or end of current message.
<span class="fc bfc" id="L821" title="All 2 branches covered.">                        if (!token.isSymbol(Token.kMessageStart)) {</span>
<span class="fc" id="L822">                            builder.set(field.getId(), context.setReference(reference, bld.build()));</span>
<span class="fc" id="L823">                            continue;</span>
                        }
<span class="pc bpc" id="L825" title="1 of 2 branches missed.">                    } else if (!token.isSymbol(Token.kMessageStart)) {</span>
<span class="nc" id="L826">                        throw new TokenizerException(token,</span>
<span class="nc" id="L827">                                                     &quot;Unexpected token &quot; + token.asString() +</span>
<span class="nc" id="L828">                                                     &quot;, expected message start&quot;).setLine(tokenizer.getLine(token.getLineNo()));</span>
                    }
                } else {
                    // extend in-line.
<span class="fc" id="L832">                    bld = builder.mutator(field.getId());</span>
                }
<span class="fc" id="L834">                builder.set(field.getId(), context.setReference(reference, parseMessage(tokenizer, context, bld)));</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">            } else if (field.getType() == PType.MAP) {</span>
                // maps can be extended the same way as
<span class="fc" id="L837">                token = tokenizer.expect(&quot;field sep or value start&quot;);</span>
<span class="fc" id="L838">                Map baseValue = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L839">                String reference = null;</span>
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">                if (token.isSymbol(kDefineReference)) {</span>
<span class="nc" id="L841">                    reference = context.initReference(tokenizer.expectIdentifier(&quot;reference name&quot;), tokenizer);</span>
<span class="nc" id="L842">                    token = tokenizer.expect(&quot;field sep or value start&quot;);</span>
                }

<span class="pc bpc" id="L845" title="1 of 2 branches missed.">                if (token.isSymbol(Token.kFieldValueSep)) {</span>
<span class="fc" id="L846">                    token = tokenizer.expect(&quot;field id or start&quot;);</span>
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">                    if (UNDEFINED.equals(token.asString())) {</span>
<span class="nc" id="L848">                        builder.clear(field.getId());</span>
<span class="nc" id="L849">                        context.setReference(reference, null);</span>

<span class="nc" id="L851">                        token = tokenizer.expect(&quot;message end or field&quot;);</span>
<span class="nc" id="L852">                        continue;</span>
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">                    } else if (token.isReferenceIdentifier()) {</span>
                        try {
<span class="nc" id="L855">                            baseValue = resolve(context, token, tokenizer, field.getDescriptor());</span>
<span class="nc" id="L856">                        } catch (KeyNotFoundException e) {</span>
<span class="nc" id="L857">                            throw new TokenizerException(token, e.getMessage())</span>
<span class="nc" id="L858">                                    .setLine(tokenizer.getLine(token.getLineNo()));</span>
<span class="nc" id="L859">                        }</span>

<span class="nc" id="L861">                        token = tokenizer.expect(&quot;map start or next field&quot;);</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">                        if (!token.isSymbol(Token.kMessageStart)) {</span>
<span class="nc" id="L863">                            builder.set(field.getId(), context.setReference(reference, baseValue));</span>
<span class="nc" id="L864">                            continue;</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">                        } else if (baseValue == null) {</span>
<span class="nc" id="L866">                            baseValue = new LinkedHashMap&lt;&gt;();</span>
                        }
                    }
                } else {
<span class="nc" id="L870">                    baseValue.putAll((Map) builder.build().get(field.getId()));</span>
                }

<span class="pc bpc" id="L873" title="1 of 2 branches missed.">                if (!token.isSymbol(Token.kMessageStart)) {</span>
<span class="nc" id="L874">                    throw new TokenizerException(token, &quot;Expected map start, but got '%s'&quot;, token.asString())</span>
<span class="nc" id="L875">                            .setLine(tokenizer.getLine(token.getLineNo()));</span>
                }
<span class="fc" id="L877">                Map map =  parseMapValue(tokenizer, context, (PMap) field.getDescriptor(), baseValue);</span>
<span class="fc" id="L878">                builder.set(field.getId(), context.setReference(reference, map));</span>
<span class="fc" id="L879">            } else {</span>
<span class="fc" id="L880">                String reference = null;</span>
                // Simple fields *must* have the '=' separation, may have '&amp;' reference.
<span class="fc bfc" id="L882" title="All 2 branches covered.">                if (tokenizer.expectSymbol(&quot;field value sep&quot;, Token.kFieldValueSep, kDefineReference) ==</span>
                    kDefineReference) {
<span class="fc" id="L884">                    reference = context.initReference(tokenizer.expectIdentifier(&quot;reference name&quot;), tokenizer);</span>
<span class="fc" id="L885">                    tokenizer.expectSymbol(&quot;field value sep&quot;, Token.kFieldValueSep);</span>
                }
<span class="fc" id="L887">                token = tokenizer.expect(&quot;field value&quot;);</span>
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">                if (UNDEFINED.equals(token.asString())) {</span>
<span class="nc" id="L889">                    builder.clear(field.getId());</span>
<span class="nc" id="L890">                    context.setReference(reference, null);</span>
                } else {
<span class="fc" id="L892">                    Object value = parseFieldValue(token, tokenizer, context, field.getDescriptor());</span>
<span class="fc" id="L893">                    builder.set(field.getId(), context.setReference(reference, value));</span>
                }
            }

<span class="fc" id="L897">            token = nextNotLineSep(tokenizer, &quot;field or message end&quot;);</span>
<span class="fc" id="L898">        }</span>

<span class="fc" id="L900">        return builder.build();</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private Map parseMapValue(Tokenizer tokenizer,
                              ProvidenceConfigContext context,
                              PMap descriptor,
                              Map builder) throws IOException {
<span class="fc" id="L908">        Token next = tokenizer.expect(&quot;map key or end&quot;);</span>
<span class="fc bfc" id="L909" title="All 2 branches covered.">        while (!next.isSymbol(Token.kMessageEnd)) {</span>
<span class="fc" id="L910">            Object key = parseFieldValue(next, tokenizer, context, descriptor.keyDescriptor());</span>
<span class="fc" id="L911">            tokenizer.expectSymbol(&quot;map key value sep&quot;, Token.kKeyValueSep);</span>
<span class="fc" id="L912">            next = tokenizer.expect(&quot;map value&quot;);</span>
<span class="pc bpc" id="L913" title="1 of 2 branches missed.">            if (UNDEFINED.equals(next.asString())) {</span>
<span class="nc" id="L914">                builder.remove(key);</span>
            } else {
<span class="fc" id="L916">                Object value = parseFieldValue(next, tokenizer, context, descriptor.itemDescriptor());</span>
<span class="fc" id="L917">                builder.put(key, value);</span>
            }
            // maps do *not* require separator, but allows ',' separator, and separator after last.
<span class="fc" id="L920">            next = tokenizer.expect(&quot;map key, end or sep&quot;);</span>
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">            if (next.isSymbol(Token.kLineSep1)) {</span>
<span class="nc" id="L922">                next = tokenizer.expect(&quot;map key or end&quot;);</span>
            }
<span class="fc" id="L924">        }</span>

<span class="fc" id="L926">        return descriptor.builder().putAll(builder).build();</span>
    }

    private Object parseFieldValue(Token next,
                                   Tokenizer tokenizer,
                                   ProvidenceConfigContext context,
                                   PDescriptor descriptor) throws IOException {
        try {
<span class="pc bpc" id="L934" title="4 of 14 branches missed.">            switch (descriptor.getType()) {</span>
                case BOOL:
<span class="pc bpc" id="L936" title="1 of 2 branches missed.">                    if (TRUE.equals(next.asString())) {</span>
<span class="nc" id="L937">                        return true;</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">                    } else if (FALSE.equals(next.asString())) {</span>
<span class="fc" id="L939">                        return false;</span>
<span class="pc bpc" id="L940" title="1 of 2 branches missed.">                    } else if (next.isReferenceIdentifier()) {</span>
<span class="fc" id="L941">                        return resolve(context, next, tokenizer, descriptor);</span>
                    }
                    break;
                case BYTE:
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">                    if (next.isReferenceIdentifier()) {</span>
<span class="fc" id="L946">                        return resolve(context, next, tokenizer, descriptor);</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">                    } else if (next.isInteger()) {</span>
<span class="nc" id="L948">                        return (byte) next.parseInteger();</span>
                    }
                    break;
                case I16:
<span class="fc bfc" id="L952" title="All 2 branches covered.">                    if (next.isReferenceIdentifier()) {</span>
<span class="fc" id="L953">                        return resolve(context, next, tokenizer, descriptor);</span>
<span class="pc bpc" id="L954" title="1 of 2 branches missed.">                    } else if (next.isInteger()) {</span>
<span class="fc" id="L955">                        return (short) next.parseInteger();</span>
                    }
                    break;
                case I32:
<span class="pc bpc" id="L959" title="1 of 2 branches missed.">                    if (next.isReferenceIdentifier()) {</span>
<span class="fc" id="L960">                        return resolve(context, next, tokenizer, descriptor);</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">                    } else if (next.isInteger()) {</span>
<span class="nc" id="L962">                        return (int) next.parseInteger();</span>
                    }
                    break;
                case I64:
<span class="pc bpc" id="L966" title="1 of 2 branches missed.">                    if (next.isReferenceIdentifier()) {</span>
<span class="fc" id="L967">                        return resolve(context, next, tokenizer, descriptor);</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">                    } else if (next.isInteger()) {</span>
<span class="nc" id="L969">                        return next.parseInteger();</span>
                    }
                    break;
                case DOUBLE:
<span class="pc bpc" id="L973" title="1 of 2 branches missed.">                    if (next.isReferenceIdentifier()) {</span>
<span class="fc" id="L974">                        return resolve(context, next, tokenizer, descriptor);</span>
<span class="nc bnc" id="L975" title="All 4 branches missed.">                    } else if (next.isInteger() || next.isReal()) {</span>
<span class="nc" id="L976">                        return next.parseDouble();</span>
                    }
                    break;
                case STRING:
<span class="fc bfc" id="L980" title="All 2 branches covered.">                    if (next.isReferenceIdentifier()) {</span>
<span class="fc" id="L981">                        return resolve(context, next, tokenizer, descriptor);</span>
<span class="pc bpc" id="L982" title="1 of 2 branches missed.">                    } else if (next.isStringLiteral()) {</span>
<span class="fc" id="L983">                        return next.decodeLiteral(strict);</span>
                    }
                    break;
                case BINARY:
<span class="fc bfc" id="L987" title="All 2 branches covered.">                    if (Token.B64.equals(next.asString())) {</span>
<span class="fc" id="L988">                        tokenizer.expectSymbol(&quot;binary data enclosing start&quot;, Token.kParamsStart);</span>
<span class="fc" id="L989">                        return Binary.fromBase64(tokenizer.readBinary(Token.kParamsEnd));</span>
<span class="pc bpc" id="L990" title="1 of 2 branches missed.">                    } else if (Token.HEX.equals(next.asString())) {</span>
<span class="nc" id="L991">                        tokenizer.expectSymbol(&quot;binary data enclosing start&quot;, Token.kParamsStart);</span>
<span class="nc" id="L992">                        return Binary.fromHexString(tokenizer.readBinary(Token.kParamsEnd));</span>
<span class="pc bpc" id="L993" title="1 of 2 branches missed.">                    } else if (next.isReferenceIdentifier()) {</span>
<span class="fc" id="L994">                        return resolve(context, next, tokenizer, descriptor);</span>
                    }
                    break;
                case ENUM: {
<span class="fc" id="L998">                    PEnumDescriptor ed = (PEnumDescriptor) descriptor;</span>
                    PEnumValue value;
<span class="pc bpc" id="L1000" title="1 of 2 branches missed.">                    if (next.isInteger()) {</span>
<span class="nc" id="L1001">                        value = ed.findById((int) next.parseInteger());</span>
<span class="pc bpc" id="L1002" title="1 of 2 branches missed.">                    } else if (next.isIdentifier()) {</span>
<span class="fc" id="L1003">                        value = ed.findByName(next.asString());</span>
<span class="pc bpc" id="L1004" title="1 of 4 branches missed.">                        if (value == null &amp;&amp; context.containsReference(next.asString())) {</span>
<span class="fc" id="L1005">                            value = resolve(context, next, tokenizer, ed);</span>
                        }
<span class="nc bnc" id="L1007" title="All 2 branches missed.">                    } else if (next.isReferenceIdentifier()) {</span>
<span class="nc" id="L1008">                        value = resolve(context, next, tokenizer, descriptor);</span>
                    } else {
                        break;
                    }
<span class="fc bfc" id="L1012" title="All 4 branches covered.">                    if (value == null &amp;&amp; strict) {</span>
<span class="fc" id="L1013">                        throw new TokenizerException(next, &quot;No such enum value %s for %s.&quot;,</span>
<span class="fc" id="L1014">                                                     next.asString(),</span>
<span class="fc" id="L1015">                                                     ed.getQualifiedName())</span>
<span class="fc" id="L1016">                                .setLine(tokenizer.getLine(next.getLineNo()));</span>
                    }
<span class="fc" id="L1018">                    return value;</span>
                }
                case MESSAGE:
<span class="nc bnc" id="L1021" title="All 2 branches missed.">                    if (next.isReferenceIdentifier()) {</span>
<span class="nc" id="L1022">                        return resolve(context, next, tokenizer, descriptor);</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">                    } else if (next.isSymbol(Token.kMessageStart)) {</span>
<span class="nc" id="L1024">                        return parseMessage(tokenizer, context, ((PMessageDescriptor) descriptor).builder());</span>
                    }
                    break;
                case MAP: {
<span class="nc bnc" id="L1028" title="All 2 branches missed.">                    if (next.isReferenceIdentifier()) {</span>
                        Map resolved;
                        try {
                            // Make sure the reference is to a map.
<span class="nc" id="L1032">                            resolved = resolve(context, next, tokenizer, descriptor);</span>
<span class="nc" id="L1033">                        } catch (ClassCastException e) {</span>
<span class="nc" id="L1034">                            throw new TokenizerException(next, &quot;Reference %s is not a map field &quot;, next.asString())</span>
<span class="nc" id="L1035">                                    .setLine(tokenizer.getLine(next.getLineNo()));</span>
<span class="nc" id="L1036">                        }</span>
<span class="nc" id="L1037">                        return resolved;</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">                    } else if (next.isSymbol(Token.kMessageStart)) {</span>
<span class="nc" id="L1039">                        return parseMapValue(tokenizer, context, (PMap) descriptor, new LinkedHashMap());</span>
                    }
                    break;
                }
                case SET: {
<span class="nc bnc" id="L1044" title="All 2 branches missed.">                    if (next.isReferenceIdentifier()) {</span>
<span class="nc" id="L1045">                        return resolve(context, next, tokenizer, descriptor);</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">                    } else if (next.isSymbol(Token.kListStart)) {</span>
                        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1048">                        PSet&lt;Object&gt; ct = (PSet) descriptor;</span>
<span class="nc" id="L1049">                        Set&lt;Object&gt; value = new LinkedHashSet&lt;&gt;();</span>

<span class="nc" id="L1051">                        next = tokenizer.expect(&quot;set value or end&quot;);</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">                        while (!next.isSymbol(Token.kListEnd)) {</span>
<span class="nc" id="L1053">                            value.add(parseFieldValue(next, tokenizer, context, ct.itemDescriptor()));</span>
                            // sets require separator, and allows separator after last.
<span class="nc bnc" id="L1055" title="All 2 branches missed.">                            if (tokenizer.expectSymbol(&quot;set separator or end&quot;, Token.kLineSep1, Token.kListEnd) == Token.kListEnd) {</span>
<span class="nc" id="L1056">                                break;</span>
                            }
<span class="nc" id="L1058">                            next = tokenizer.expect(&quot;set value or end&quot;);</span>
                        }

<span class="nc" id="L1061">                        return ct.builder()</span>
<span class="nc" id="L1062">                                 .addAll(value)</span>
<span class="nc" id="L1063">                                 .build();</span>
                    }
                    break;
                }
                case LIST: {
<span class="pc bpc" id="L1068" title="1 of 2 branches missed.">                    if (next.isReferenceIdentifier()) {</span>
<span class="nc" id="L1069">                        return resolve(context, next, tokenizer, descriptor);</span>
<span class="pc bpc" id="L1070" title="1 of 2 branches missed.">                    } else if (next.isSymbol(Token.kListStart)) {</span>
                        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1072">                        PList&lt;Object&gt; ct = (PList) descriptor;</span>
<span class="fc" id="L1073">                        PList.Builder&lt;Object&gt; builder = ct.builder();</span>

<span class="fc" id="L1075">                        next = tokenizer.expect(&quot;list value or end&quot;);</span>
<span class="pc bpc" id="L1076" title="1 of 2 branches missed.">                        while (!next.isSymbol(Token.kListEnd)) {</span>
<span class="fc" id="L1077">                            builder.add(parseFieldValue(next, tokenizer, context, ct.itemDescriptor()));</span>
                            // lists require separator, and allows separator after last.
<span class="pc bpc" id="L1079" title="1 of 2 branches missed.">                            if (tokenizer.expectSymbol(&quot;list separator or end&quot;, Token.kLineSep1, Token.kListEnd) == Token.kListEnd) {</span>
<span class="fc" id="L1080">                                break;</span>
                            }
<span class="nc" id="L1082">                            next = tokenizer.expect(&quot;list value or end&quot;);</span>
                        }

<span class="fc" id="L1085">                        return builder.build();</span>
                    }
                    break;
                }
                default: {
<span class="nc" id="L1090">                    throw new TokenizerException(next, descriptor.getType() + &quot; not supported!&quot;).setLine(tokenizer.getLine(</span>
<span class="nc" id="L1091">                            next.getLineNo()));</span>
                }
            }
<span class="nc" id="L1094">        } catch (KeyNotFoundException e) {</span>
<span class="nc" id="L1095">            throw new TokenizerException(next, e.getMessage())</span>
<span class="nc" id="L1096">                    .setLine(tokenizer.getLine(next.getLineNo()));</span>
<span class="nc" id="L1097">        }</span>

<span class="nc" id="L1099">        throw new TokenizerException(next, &quot;Unhandled value \&quot;%s\&quot; for type %s&quot;,</span>
<span class="nc" id="L1100">                                     next.asString(),</span>
<span class="nc" id="L1101">                                     descriptor.getType())</span>
<span class="nc" id="L1102">                .setLine(tokenizer.getLine(next.getLineNo()));</span>
    }

    private Token nextNotLineSep(Tokenizer tokenizer, String message) throws IOException {
<span class="pc bpc" id="L1106" title="1 of 2 branches missed.">        if (tokenizer.peek().isSymbol(Token.kLineSep1) ||</span>
<span class="pc bpc" id="L1107" title="1 of 2 branches missed.">            tokenizer.peek().isSymbol(Token.kLineSep2)) {</span>
<span class="nc" id="L1108">            tokenizer.expect(message);</span>
        }
<span class="fc" id="L1110">        return tokenizer.expect(message);</span>
    }

    /**
     * Resolve a value reference.
     *
     * @param context The parsing context.
     * @param token The ID token to look for.
     * @param tokenizer The tokenizer.
     * @param descriptor The item descriptor.
     * @return The value at the given key, or exception if not found.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;V&gt; V resolve(ProvidenceConfigContext context,
                          Token token,
                          Tokenizer tokenizer,
                          PDescriptor descriptor) throws TokenizerException {
<span class="fc" id="L1127">        Object value = resolveAny(context, token, tokenizer);</span>
<span class="pc bpc" id="L1128" title="1 of 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L1129">            return null;</span>
        }
<span class="pc bpc" id="L1131" title="3 of 13 branches missed.">        switch (descriptor.getType()) {</span>
            case BOOL:
<span class="fc" id="L1133">                return (V) (Object) asBoolean(value);</span>
            case BYTE:
<span class="fc" id="L1135">                return (V) (Object) (byte) asInteger(value);</span>
            case I16:
<span class="fc" id="L1137">                return (V) (Object) (short) asInteger(value);</span>
            case I32:
<span class="fc" id="L1139">                return (V) (Object) asInteger(value);</span>
            case I64:
<span class="fc" id="L1141">                return (V) (Object) asLong(value);</span>
            case DOUBLE:
<span class="fc" id="L1143">                return (V) (Object) asDouble(value);</span>
            case ENUM:
<span class="pc bpc" id="L1145" title="1 of 2 branches missed.">                if (value instanceof PEnumValue) {</span>
<span class="fc" id="L1146">                    PEnumValue verified = ((PEnumDescriptor) descriptor).findById(((PEnumValue) value).asInteger());</span>
<span class="pc bpc" id="L1147" title="1 of 2 branches missed.">                    if (value.equals(verified)) {</span>
<span class="fc" id="L1148">                        return (V) value;</span>
                    }
<span class="nc bnc" id="L1150" title="All 2 branches missed.">                } else if (value instanceof Number) {</span>
<span class="nc" id="L1151">                    return (V) ((PEnumDescriptor) descriptor).findById(((Number) value).intValue());</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">                } else if (value instanceof CharSequence) {</span>
<span class="nc" id="L1153">                    return (V) ((PEnumDescriptor) descriptor).findByName(value.toString());</span>
                }
<span class="nc" id="L1155">                throw new IncompatibleValueException(value.getClass().getSimpleName() + &quot; is not compatible with &quot; + descriptor.getQualifiedName());</span>
            case STRING:
<span class="fc" id="L1157">                return (V) asString(value);</span>
            case BINARY:
<span class="pc bpc" id="L1159" title="1 of 2 branches missed.">                if (value instanceof Binary) {</span>
<span class="fc" id="L1160">                    return (V) value;</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">                } else if (value instanceof CharSequence) {</span>
<span class="nc" id="L1162">                    return (V) Binary.fromBase64(value.toString());</span>
                }
<span class="nc" id="L1164">                throw new IncompatibleValueException(value.getClass().getSimpleName() + &quot; is not compatible with binary&quot;);</span>
            case MAP:
<span class="nc bnc" id="L1166" title="All 2 branches missed.">                if (value instanceof Map) {</span>
<span class="nc" id="L1167">                    return (V) value;</span>
                }
<span class="nc" id="L1169">                throw new IncompatibleValueException(value.getClass().getSimpleName() + &quot; is not compatible with map&quot;);</span>
            case SET:
            case LIST:
<span class="nc bnc" id="L1172" title="All 2 branches missed.">                if (value instanceof Collection) {</span>
<span class="nc" id="L1173">                    return (V) value;</span>
                }
<span class="nc" id="L1175">                throw new IncompatibleValueException(value.getClass().getSimpleName() + &quot; is not compatible with &quot; + descriptor.getType());</span>
            case MESSAGE:
<span class="pc bpc" id="L1177" title="1 of 2 branches missed.">                if (value instanceof PMessage) {</span>
<span class="pc bpc" id="L1178" title="1 of 2 branches missed.">                    if (descriptor.equals(((PMessage) value).descriptor())) {</span>
<span class="fc" id="L1179">                        return (V) value;</span>
                    }
                }
<span class="nc" id="L1182">                throw new IncompatibleValueException(value.getClass().getSimpleName() + &quot; is not compatible with &quot; + descriptor.getQualifiedName());</span>
            default:
<span class="nc" id="L1184">                throw new IllegalArgumentException(&quot;Type &quot; + descriptor.getType() + &quot; is not handled by config.&quot;);</span>
        }
    }

    private Object resolveAny(ProvidenceConfigContext context, Token token, Tokenizer tokenizer)
            throws TokenizerException {
<span class="fc" id="L1190">        String key = token.asString();</span>

<span class="fc" id="L1192">        String name = key;</span>
<span class="fc" id="L1193">        String subKey = null;</span>

<span class="pc bpc" id="L1195" title="1 of 2 branches missed.">        if (key.contains(IDENTIFIER_SEP)) {</span>
<span class="nc" id="L1196">            int idx = key.indexOf(IDENTIFIER_SEP);</span>
<span class="nc" id="L1197">            name = key.substring(0, idx);</span>
<span class="nc" id="L1198">            subKey = key.substring(idx + 1);</span>
        }

<span class="fc" id="L1201">        Object value = context.getReference(name, token, tokenizer);</span>
<span class="pc bpc" id="L1202" title="1 of 2 branches missed.">        if (subKey != null) {</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">            if (!(value instanceof PMessage)) {</span>
<span class="nc" id="L1204">                throw new TokenizerException(token, &quot;Reference name &quot; + key + &quot; not declared&quot;);</span>
            }
            try {
<span class="nc" id="L1207">                return ProvidenceConfigUtil.getInMessage((PMessage) value, subKey, null);</span>
<span class="nc" id="L1208">            } catch (KeyNotFoundException | IncompatibleValueException e) {</span>
<span class="nc" id="L1209">                throw new TokenizerException(token, e.getMessage())</span>
<span class="nc" id="L1210">                        .setLine(tokenizer.getLine(token.getLineNo()))</span>
<span class="nc" id="L1211">                        .initCause(e);</span>
            }
        }
<span class="fc" id="L1214">        return value;</span>
    }

    private static final String IDENTIFIER_SEP = &quot;.&quot;;

    private static final String FALSE     = &quot;false&quot;;
    private static final String TRUE      = &quot;true&quot;;
    private static final String DEF       = &quot;def&quot;;
            static final String UNDEFINED = &quot;undefined&quot;;
    private static final String INCLUDE   = &quot;include&quot;;
    private static final String AS        = &quot;as&quot;;

<span class="fc" id="L1226">    static final Set&lt;String&gt; RESERVED_WORDS = ImmutableSet.of(</span>
            TRUE,
            FALSE,
            UNDEFINED,
            DEF,
            AS,
            INCLUDE
    );

    private static final char kDefineReference = '&amp;';

    /**
     * Full path to resolved instance.
     */
    private final Map&lt;String, AtomicReference&lt;PMessage&gt;&gt; loaded;

    /**
     * Some configs have defined 'parents'. The parent must be of the
     * same type as the config, and will be the base of the config
     * as it is parsed. It can reference any type of providence message
     * source.
     * &lt;p&gt;
     * The configs that has defined parents can not have explicit parents
     * (with the &lt;code&gt;type : parent { ... }&lt;/code&gt; syntax.
     */
    private final Map&lt;String, Supplier&lt;PMessage&gt;&gt; parents;

    /**
     * Type registry for looking up the base config types.
     */
    private final TypeRegistry             registry;

    /**
     * Map of input params used to override the
     */
    private final Map&lt;String, Set&lt;String&gt;&gt; reverseDependencies;

    /**
     * If config should be parsed strictly.
     */
    private final boolean                  strict;

    /**
     * Simple stage separation. The content *must* come in this order.
     */
<span class="pc" id="L1271">    private enum Stage {</span>
<span class="fc" id="L1272">        INCLUDES,</span>
<span class="fc" id="L1273">        DEFINES,</span>
<span class="fc" id="L1274">        MESSAGE</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>