<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonSerializer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Providence Core</a> &gt; <a href="index.source.html" class="el_package">net.morimekta.providence.serializer</a> &gt; <span class="el_source">JsonSerializer.java</span></div><h1>JsonSerializer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015-2016 Providence Authors
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package net.morimekta.providence.serializer;

import net.morimekta.providence.PApplicationException;
import net.morimekta.providence.PApplicationExceptionType;
import net.morimekta.providence.PEnumBuilder;
import net.morimekta.providence.PEnumValue;
import net.morimekta.providence.PMessage;
import net.morimekta.providence.PMessageBuilder;
import net.morimekta.providence.PServiceCall;
import net.morimekta.providence.PServiceCallType;
import net.morimekta.providence.PUnion;
import net.morimekta.providence.descriptor.PContainer;
import net.morimekta.providence.descriptor.PDescriptor;
import net.morimekta.providence.descriptor.PEnumDescriptor;
import net.morimekta.providence.descriptor.PField;
import net.morimekta.providence.descriptor.PList;
import net.morimekta.providence.descriptor.PMap;
import net.morimekta.providence.descriptor.PMessageDescriptor;
import net.morimekta.providence.descriptor.PService;
import net.morimekta.providence.descriptor.PServiceMethod;
import net.morimekta.providence.descriptor.PSet;
import net.morimekta.providence.serializer.json.JsonCompactible;
import net.morimekta.providence.serializer.json.JsonCompactibleDescriptor;
import net.morimekta.util.Binary;
import net.morimekta.util.Strings;
import net.morimekta.util.io.CountingOutputStream;
import net.morimekta.util.json.JsonException;
import net.morimekta.util.json.JsonToken;
import net.morimekta.util.json.JsonTokenizer;
import net.morimekta.util.json.JsonWriter;
import net.morimekta.util.json.PrettyJsonWriter;

import javax.annotation.Nonnull;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.Map;

import static java.util.Objects.requireNonNull;

/**
 * Compact JSON serializer. This uses the most compact type-safe JSON format
 * allowable. There are two optional variants switching the struct field ID
 * between numeric ID and field name.
 * &lt;p&gt;
 * There is also the strict mode. If strict is OFF:
 * - Unknown enum values will be ignored (as field missing).
 * - Message validity will be ignored.
 * If strict more is ON:
 * - Unknown enum values will fail deserialization.
 * - Message invalidity will fail deserialization.
 * &lt;p&gt;
 * Format is like this:
 * &lt;pre&gt;
 * {
 *     &quot;id&quot;:value,
 *     &quot;structId&quot;:{ ... },
 *     &quot;listId&quot;:[value1,value2],
 *     &quot;mapId&quot;:{&quot;id1&quot;:value1,&quot;id2&quot;:value2}
 * }
 * &lt;/pre&gt;
 * But without formatting spaces. The formatted JSON can be read normally.
 * Binary fields are base64 encoded.
 * &lt;p&gt;
 * This format supports 'compact' struct formatting. A compact struct is
 * formatted as a list with fields in order from 1 to N. E.g.:
 * &lt;pre&gt;
 * [&quot;tag&quot;,5,6.45]
 * &lt;/pre&gt;
 * is equivalent to:
 * &lt;pre&gt;
 * {&quot;1&quot;:&quot;tag&quot;,&quot;2&quot;:5,&quot;3&quot;:6.45}
 * &lt;/pre&gt;
 */
public class JsonSerializer extends Serializer {
    public static final String MEDIA_TYPE      = &quot;application/vnd.morimekta.providence.json&quot;;
    public static final String JSON_MEDIA_TYPE = &quot;application/json&quot;;

    public JsonSerializer() {
<span class="fc" id="L104">        this(DEFAULT_STRICT, false, IdType.ID, IdType.ID);</span>
<span class="fc" id="L105">    }</span>

    public JsonSerializer(boolean strict) {
<span class="fc" id="L108">        this(strict, false, IdType.ID, IdType.ID);</span>
<span class="fc" id="L109">    }</span>

    public JsonSerializer pretty() {
<span class="fc" id="L112">        return new JsonSerializer(readStrict, true, IdType.NAME, IdType.NAME);</span>
    }

    public JsonSerializer named() {
<span class="fc" id="L116">        return withNamedEnums().withNamedFields();</span>
    }

    public JsonSerializer withNamedFields() {
<span class="fc" id="L120">        return new JsonSerializer(readStrict, prettyPrint, IdType.NAME, enumValueType);</span>
    }

    public JsonSerializer withNamedEnums() {
<span class="fc" id="L124">        return new JsonSerializer(readStrict, prettyPrint, fieldIdType, IdType.NAME);</span>
    }

    @Override
    public &lt;T extends PMessage&lt;T, F&gt;, F extends PField&gt; int serialize(@Nonnull OutputStream output, @Nonnull T message) throws IOException {
<span class="fc" id="L129">        CountingOutputStream counter = new CountingOutputStream(output);</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">        JsonWriter jsonWriter = prettyPrint ? new PrettyJsonWriter(counter) : new JsonWriter(counter);</span>
<span class="fc" id="L131">        appendMessage(jsonWriter, message);</span>
<span class="fc" id="L132">        jsonWriter.flush();</span>
<span class="fc" id="L133">        counter.flush();</span>
<span class="fc" id="L134">        return counter.getByteCount();</span>
    }

    @Override
    public &lt;T extends PMessage&lt;T, F&gt;, F extends PField&gt; int serialize(@Nonnull OutputStream output, @Nonnull
            PServiceCall&lt;T, F&gt; call)
            throws IOException {
<span class="fc" id="L141">        CountingOutputStream counter = new CountingOutputStream(output);</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        JsonWriter jsonWriter = prettyPrint ? new PrettyJsonWriter(counter) : new JsonWriter(counter);</span>

<span class="fc" id="L144">        jsonWriter.array().value(call.getMethod());</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">        if (enumValueType == IdType.ID) {</span>
<span class="fc" id="L146">            jsonWriter.value(call.getType().asInteger());</span>
        } else {
<span class="fc" id="L148">            jsonWriter.valueUnescaped(call.getType().asString());</span>
        }
<span class="fc" id="L150">        jsonWriter.value(call.getSequence());</span>

<span class="fc" id="L152">        appendMessage(jsonWriter, call.getMessage());</span>

<span class="fc" id="L154">        jsonWriter.endArray().flush();</span>
<span class="fc" id="L155">        counter.flush();</span>
<span class="fc" id="L156">        return counter.getByteCount();</span>

    }

    @Nonnull
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T extends PMessage&lt;T, TF&gt;, TF extends PField&gt; T deserialize(
            @Nonnull InputStream input, @Nonnull PMessageDescriptor&lt;T, TF&gt; type) throws IOException {
        try {
<span class="fc" id="L166">            JsonTokenizer tokenizer = new JsonTokenizer(input);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">            if (!tokenizer.hasNext()) {</span>
<span class="fc" id="L168">                throw new SerializerException(&quot;Empty json body&quot;);</span>
            }
<span class="fc" id="L170">            return requireNonNull((T) parseTypedValue(tokenizer.next(), tokenizer, type, false));</span>
<span class="fc" id="L171">        } catch (JsonException e) {</span>
<span class="fc" id="L172">            throw new JsonSerializerException(e);</span>
        }
    }

    @Nonnull
    @Override
    public &lt;T extends PMessage&lt;T, F&gt;, F extends PField&gt; PServiceCall&lt;T, F&gt; deserialize(@Nonnull InputStream input, @Nonnull
            PService service)
            throws IOException {
<span class="fc" id="L181">        JsonTokenizer tokenizer = new JsonTokenizer(input);</span>
<span class="fc" id="L182">        return parseServiceCall(tokenizer, service);</span>
    }

    @Override
    public boolean binaryProtocol() {
<span class="fc" id="L187">        return false;</span>
    }

    @Nonnull
    @Override
    public String mediaType() {
<span class="fc" id="L193">        return MEDIA_TYPE;</span>
    }

    // ------------------- PRIVATE ONLY ------------------

<span class="fc" id="L198">    private JsonSerializer(boolean readStrict, boolean prettyPrint, IdType fieldIdType, IdType enumValueType) {</span>
<span class="fc" id="L199">        this.readStrict = readStrict;</span>
<span class="fc" id="L200">        this.prettyPrint = prettyPrint;</span>
<span class="fc" id="L201">        this.fieldIdType = fieldIdType;</span>
<span class="fc" id="L202">        this.enumValueType = enumValueType;</span>
<span class="fc" id="L203">    }</span>

<span class="pc" id="L205">    private enum IdType {</span>
        // print field or enums as numeric IDs and values.
<span class="fc" id="L207">        ID,</span>
        // print field or enums as field name and enum name.
<span class="fc" id="L209">        NAME</span>
    }

    private final boolean readStrict;
    private final IdType  fieldIdType;
    private final IdType  enumValueType;
    private final boolean prettyPrint;

    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;T extends PMessage&lt;T, F&gt;, F extends PField&gt; PServiceCall&lt;T, F&gt; parseServiceCall(JsonTokenizer tokenizer, PService service)
            throws IOException {
<span class="fc" id="L220">        PServiceCallType type = null;</span>
<span class="fc" id="L221">        String methodName = null;</span>
<span class="fc" id="L222">        int sequence = 0;</span>
        try {
<span class="fc" id="L224">            tokenizer.expectSymbol(&quot;service call start&quot;, JsonToken.kListStart);</span>

<span class="fc" id="L226">            methodName = tokenizer.expectString(&quot;method name&quot;)</span>
<span class="fc" id="L227">                                  .rawJsonLiteral();</span>

<span class="fc" id="L229">            tokenizer.expectSymbol(&quot;entry sep&quot;, JsonToken.kListSep);</span>

<span class="fc" id="L231">            JsonToken callTypeToken = tokenizer.expect(&quot;call type&quot;);</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">            if (callTypeToken.isInteger()) {</span>
<span class="fc" id="L233">                int typeKey = callTypeToken.byteValue();</span>
<span class="fc" id="L234">                type = PServiceCallType.findById(typeKey);</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">                if (type == null) {</span>
<span class="fc" id="L236">                    throw new SerializerException(&quot;Service call type &quot; + typeKey + &quot; is not valid&quot;)</span>
<span class="fc" id="L237">                            .setExceptionType(PApplicationExceptionType.INVALID_MESSAGE_TYPE);</span>
                }
<span class="fc bfc" id="L239" title="All 2 branches covered.">            } else if (callTypeToken.isLiteral()) {</span>
<span class="fc" id="L240">                String typeName = callTypeToken.rawJsonLiteral();</span>
<span class="fc" id="L241">                type = PServiceCallType.findByName(typeName);</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">                if (type == null) {</span>
<span class="fc" id="L243">                    throw new SerializerException(&quot;Service call type \&quot;&quot; + Strings.escape(typeName) + &quot;\&quot; is not valid&quot;)</span>
<span class="fc" id="L244">                            .setExceptionType(PApplicationExceptionType.INVALID_MESSAGE_TYPE);</span>
                }
<span class="fc" id="L246">            } else {</span>
<span class="fc" id="L247">                throw new SerializerException(&quot;Invalid service call type token &quot; + callTypeToken.asString())</span>
<span class="fc" id="L248">                        .setExceptionType(PApplicationExceptionType.INVALID_MESSAGE_TYPE);</span>
            }

<span class="fc" id="L251">            tokenizer.expectSymbol(&quot;entry sep&quot;, JsonToken.kListSep);</span>

<span class="fc" id="L253">            sequence = tokenizer.expectNumber(&quot;Service call sequence&quot;)</span>
<span class="fc" id="L254">                                .intValue();</span>

<span class="fc" id="L256">            tokenizer.expectSymbol(&quot;entry sep&quot;, JsonToken.kListSep);</span>

<span class="fc bfc" id="L258" title="All 2 branches covered.">            if (type == PServiceCallType.EXCEPTION) {</span>
<span class="fc" id="L259">                PApplicationException ex = (PApplicationException) parseTypedValue(tokenizer.expect(&quot;Message start&quot;),</span>
                                                                                   tokenizer,
                                                                                   PApplicationException.kDescriptor,
                                                                                   false);

<span class="fc" id="L264">                tokenizer.expectSymbol(&quot;service call end&quot;, JsonToken.kListEnd);</span>

<span class="fc" id="L266">                return (PServiceCall&lt;T, F&gt;) new PServiceCall&lt;&gt;(methodName, type, sequence, ex);</span>
            }

<span class="fc" id="L269">            PServiceMethod method = service.getMethod(methodName);</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">            if (method == null) {</span>
<span class="nc" id="L271">                throw new SerializerException(&quot;No such method &quot; + methodName + &quot; on &quot; + service.getQualifiedName())</span>
<span class="nc" id="L272">                        .setExceptionType(PApplicationExceptionType.UNKNOWN_METHOD);</span>
            }

            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc bfc" id="L276" title="All 2 branches covered.">            PMessageDescriptor&lt;T, F&gt; descriptor = isRequestCallType(type) ? method.getRequestType() : method.getResponseType();</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">            if (descriptor == null) {</span>
<span class="fc" id="L278">                throw new SerializerException(&quot;No %s type for %s.%s()&quot;,</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">                                              isRequestCallType(type) ? &quot;request&quot; : &quot;response&quot;,</span>
<span class="fc" id="L280">                                              service.getQualifiedName(), methodName)</span>
<span class="fc" id="L281">                        .setExceptionType(PApplicationExceptionType.UNKNOWN_METHOD);</span>
            }
<span class="fc" id="L283">            T message = (T) parseTypedValue(tokenizer.expect(&quot;message start&quot;), tokenizer, descriptor, false);</span>

<span class="fc" id="L285">            tokenizer.expectSymbol(&quot;service call end&quot;, JsonToken.kListEnd);</span>

<span class="fc" id="L287">            return new PServiceCall&lt;&gt;(methodName, type, sequence, message);</span>
<span class="fc" id="L288">        } catch (SerializerException se) {</span>
<span class="fc" id="L289">            throw new SerializerException(se)</span>
<span class="fc" id="L290">                    .setMethodName(methodName)</span>
<span class="fc" id="L291">                    .setCallType(type)</span>
<span class="fc" id="L292">                    .setSequenceNo(sequence);</span>
<span class="fc" id="L293">        } catch (JsonException je) {</span>
<span class="fc" id="L294">            throw new JsonSerializerException(je)</span>
<span class="fc" id="L295">                    .setMethodName(methodName)</span>
<span class="fc" id="L296">                    .setCallType(type)</span>
<span class="fc" id="L297">                    .setSequenceNo(sequence);</span>
        }
    }

    private &lt;T extends PMessage&lt;T, F&gt;, F extends PField&gt; T parseMessage(JsonTokenizer tokenizer, PMessageDescriptor&lt;T, F&gt; type)
            throws JsonException, IOException {
<span class="fc" id="L303">        PMessageBuilder&lt;T, F&gt; builder = type.builder();</span>

<span class="fc bfc" id="L305" title="All 2 branches covered.">        if (tokenizer.peek(&quot;message end or key&quot;).isSymbol(JsonToken.kMapEnd)) {</span>
<span class="fc" id="L306">            tokenizer.next();</span>
        } else {
<span class="fc" id="L308">            char sep = JsonToken.kMapStart;</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">            while (sep != JsonToken.kMapEnd) {</span>
<span class="fc" id="L310">                JsonToken token = tokenizer.expectString(&quot;field spec&quot;);</span>
<span class="fc" id="L311">                String key = token.rawJsonLiteral();</span>
                PField field;
<span class="fc bfc" id="L313" title="All 2 branches covered.">                if (Strings.isInteger(key)) {</span>
<span class="fc" id="L314">                    field = type.findFieldById(Integer.parseInt(key));</span>
                } else {
<span class="fc" id="L316">                    field = type.findFieldByName(key);</span>
                }
<span class="fc" id="L318">                tokenizer.expectSymbol(&quot;field KV sep&quot;, JsonToken.kKeyValSep);</span>

<span class="fc bfc" id="L320" title="All 2 branches covered.">                if (field != null) {</span>
<span class="fc" id="L321">                    Object value = parseTypedValue(tokenizer.expect(&quot;field value&quot;), tokenizer, field.getDescriptor(), true);</span>
<span class="fc" id="L322">                    builder.set(field.getId(), value);</span>
<span class="fc" id="L323">                } else {</span>
<span class="fc" id="L324">                    consume(tokenizer.expect(&quot;field value&quot;), tokenizer);</span>
                }

<span class="fc" id="L327">                sep = tokenizer.expectSymbol(&quot;message end or sep&quot;, JsonToken.kMapEnd, JsonToken.kListSep);</span>
<span class="fc" id="L328">            }</span>
        }

<span class="fc bfc" id="L331" title="All 2 branches covered.">        if (readStrict) {</span>
            try {
<span class="fc" id="L333">                builder.validate();</span>
<span class="fc" id="L334">            } catch (IllegalStateException e) {</span>
<span class="fc" id="L335">                throw new SerializerException(e, e.getMessage());</span>
<span class="fc" id="L336">            }</span>
        }

<span class="fc" id="L339">        return builder.build();</span>
    }

    private &lt;T extends PMessage&lt;T, F&gt;, F extends PField&gt; T parseCompactMessage(JsonTokenizer tokenizer, PMessageDescriptor&lt;T, F&gt; type)
            throws IOException, JsonException {
<span class="fc" id="L344">        PMessageBuilder&lt;T, F&gt; builder = type.builder();</span>
        // compact message are not allowed to be empty.

<span class="fc" id="L347">        int i = 0;</span>
<span class="fc" id="L348">        char sep = JsonToken.kListStart;</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">        while (sep != JsonToken.kListEnd) {</span>
<span class="fc" id="L350">            PField field = type.findFieldById(++i);</span>

<span class="pc bpc" id="L352" title="1 of 2 branches missed.">            if (field != null) {</span>
<span class="fc" id="L353">                Object value = parseTypedValue(tokenizer.expect(&quot;field value&quot;), tokenizer, field.getDescriptor(), true);</span>
<span class="fc" id="L354">                builder.set(i, value);</span>
<span class="fc" id="L355">            } else {</span>
<span class="nc" id="L356">                consume(tokenizer.expect(&quot;compact field value&quot;), tokenizer);</span>
            }

<span class="fc" id="L359">            sep = tokenizer.expectSymbol(&quot;compact entry sep&quot;, JsonToken.kListEnd, JsonToken.kListSep);</span>
<span class="fc" id="L360">        }</span>

<span class="fc bfc" id="L362" title="All 2 branches covered.">        if (readStrict) {</span>
            try {
<span class="fc" id="L364">                builder.validate();</span>
<span class="nc" id="L365">            } catch (IllegalStateException e) {</span>
<span class="nc" id="L366">                throw new SerializerException(e, e.getMessage());</span>
<span class="fc" id="L367">            }</span>
        }

<span class="fc" id="L370">        return builder.build();</span>
    }

    private void consume(JsonToken token, JsonTokenizer tokenizer) throws IOException, JsonException {
<span class="fc bfc" id="L374" title="All 2 branches covered.">        if (token.isSymbol()) {</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">            if (token.isSymbol(JsonToken.kListStart)) {</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">                if (tokenizer.peek(&quot;lists end or value&quot;).isSymbol(JsonToken.kListEnd)) {</span>
<span class="fc" id="L377">                    tokenizer.next();</span>
                } else {
<span class="fc" id="L379">                    char sep = JsonToken.kListStart;</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">                    while (sep != JsonToken.kListEnd) {</span>
<span class="fc" id="L381">                        consume(tokenizer.expect(&quot;list item&quot;), tokenizer);</span>
<span class="fc" id="L382">                        sep = tokenizer.expectSymbol(&quot;list sep&quot;, JsonToken.kListEnd, JsonToken.kListSep);</span>
                    }
<span class="fc" id="L384">                }</span>
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">            } else if (token.isSymbol(JsonToken.kMapStart)) {</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">                if (tokenizer.peek(&quot;map end or key&quot;).isSymbol(JsonToken.kMapEnd)) {</span>
<span class="nc" id="L387">                    tokenizer.next();</span>
                } else {
<span class="fc" id="L389">                    char sep = JsonToken.kMapStart;</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">                    while (sep != JsonToken.kMapEnd) {</span>
<span class="fc" id="L391">                        tokenizer.expectString(&quot;map key&quot;);</span>
<span class="fc" id="L392">                        tokenizer.expectSymbol(&quot;map KV sep&quot;, JsonToken.kKeyValSep);</span>
<span class="fc" id="L393">                        consume(tokenizer.expect(&quot;entry value&quot;), tokenizer);</span>
<span class="fc" id="L394">                        sep = tokenizer.expectSymbol(&quot;map end or sep&quot;, JsonToken.kMapEnd, JsonToken.kListSep);</span>
                    }
                }
            }
        }
        // Otherwise it is a simple value. No need to consume.
<span class="fc" id="L400">    }</span>

    private Object parseTypedValue(JsonToken token, JsonTokenizer tokenizer, PDescriptor t, boolean allowNull)
            throws IOException, JsonException {
<span class="fc bfc" id="L404" title="All 2 branches covered.">        if (token.isNull()) {</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">            if (!allowNull) {</span>
<span class="fc" id="L406">                throw new SerializerException(&quot;Null value as body.&quot;);</span>
            }
<span class="nc" id="L408">            return null;</span>
        }

<span class="pc bpc" id="L411" title="1 of 15 branches missed.">        switch (t.getType()) {</span>
            case VOID: {
<span class="fc bfc" id="L413" title="All 2 branches covered.">                if (token.isBoolean()) {</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">                    return token.booleanValue() ? Boolean.TRUE : null;</span>
                }
<span class="fc" id="L416">                throw new SerializerException(&quot;Not a void token value: '&quot; + token.asString() + &quot;'&quot;);</span>
            }
            case BOOL:
<span class="fc bfc" id="L419" title="All 2 branches covered.">                if (token.isBoolean()) {</span>
<span class="fc" id="L420">                    return token.booleanValue();</span>
                }
<span class="fc" id="L422">                throw new SerializerException(&quot;No boolean value for token: '&quot; + token.asString() + &quot;'&quot;);</span>
            case BYTE:
<span class="fc bfc" id="L424" title="All 2 branches covered.">                if (token.isInteger()) {</span>
<span class="fc" id="L425">                    return token.byteValue();</span>
                }
<span class="fc" id="L427">                throw new SerializerException(&quot;Not a valid byte value: '&quot; + token.asString() + &quot;'&quot;);</span>
            case I16:
<span class="fc bfc" id="L429" title="All 2 branches covered.">                if (token.isInteger()) {</span>
<span class="fc" id="L430">                    return token.shortValue();</span>
                }
<span class="fc" id="L432">                throw new SerializerException(&quot;Not a valid short value: '&quot; + token.asString() + &quot;'&quot;);</span>
            case I32:
<span class="fc bfc" id="L434" title="All 2 branches covered.">                if (token.isInteger()) {</span>
<span class="fc" id="L435">                    return token.intValue();</span>
                }
<span class="fc" id="L437">                throw new SerializerException(&quot;Not a valid int value: '&quot; + token.asString() + &quot;'&quot;);</span>
            case I64:
<span class="fc bfc" id="L439" title="All 2 branches covered.">                if (token.isInteger()) {</span>
<span class="fc" id="L440">                    return token.longValue();</span>
                }
<span class="fc" id="L442">                throw new SerializerException(&quot;Not a valid long value: '&quot; + token.asString() + &quot;'&quot;);</span>
            case DOUBLE:
<span class="fc bfc" id="L444" title="All 2 branches covered.">                if (token.isNumber()) {</span>
<span class="fc" id="L445">                    return token.doubleValue();</span>
                }
<span class="fc" id="L447">                throw new SerializerException(&quot;Not a valid double value: '&quot; + token.asString() + &quot;'&quot;);</span>
            case STRING:
<span class="fc bfc" id="L449" title="All 2 branches covered.">                if (token.isLiteral()) {</span>
<span class="fc" id="L450">                    return token.decodeJsonLiteral();</span>
                }
<span class="fc" id="L452">                throw new SerializerException(&quot;Not a valid string value: '&quot; + token.asString() + &quot;'&quot;);</span>
            case BINARY:
<span class="fc bfc" id="L454" title="All 2 branches covered.">                if (token.isLiteral()) {</span>
                    try {
<span class="fc" id="L456">                        return Binary.fromBase64(token.rawJsonLiteral());</span>
<span class="fc" id="L457">                    } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L458">                        throw new SerializerException(e, &quot;Unable to parse Base64 data: &quot; + token.asString());</span>
                    }
                }
<span class="fc" id="L461">                throw new SerializerException(&quot;Not a valid binary value: &quot; + token.asString());</span>
            case ENUM:
<span class="fc" id="L463">                PEnumBuilder&lt;?&gt; eb = ((PEnumDescriptor&lt;?&gt;) t).builder();</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">                if (token.isInteger()) {</span>
<span class="fc" id="L465">                    eb.setById(token.intValue());</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">                } else if (token.isLiteral()) {</span>
<span class="fc" id="L467">                    eb.setByName(token.rawJsonLiteral());</span>
                } else {
<span class="fc" id="L469">                    throw new SerializerException(token.asString() + &quot; is not a enum value type&quot;);</span>
                }
<span class="fc bfc" id="L471" title="All 4 branches covered.">                if (!(allowNull || eb.valid())) {</span>
<span class="fc" id="L472">                    throw new SerializerException(token.asString() + &quot; is not a known enum value for &quot; + t.getQualifiedName());</span>
                }
<span class="fc" id="L474">                return eb.build();</span>
            case MESSAGE: {
<span class="fc" id="L476">                PMessageDescriptor&lt;?, ?&gt; st = (PMessageDescriptor&lt;?, ?&gt;) t;</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">                if (token.isSymbol(JsonToken.kMapStart)) {</span>
<span class="fc" id="L478">                    return parseMessage(tokenizer, st);</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">                } else if (token.isSymbol(JsonToken.kListStart)) {</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">                    if (isCompactible(st)) {</span>
<span class="fc" id="L481">                        return parseCompactMessage(tokenizer, st);</span>
                    } else {
<span class="fc" id="L483">                        throw new SerializerException(</span>
<span class="fc" id="L484">                                st.getName() + &quot; is not compatible for compact struct notation.&quot;);</span>
                    }
                }
<span class="fc" id="L487">                throw new SerializerException(&quot;expected message start, found: '%s'&quot;, token.asString());</span>
            }
            case MAP: {
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L491">                PMap&lt;Object, Object&gt; mapType = (PMap&lt;Object, Object&gt;) t;</span>
<span class="fc" id="L492">                PDescriptor itemType = mapType.itemDescriptor();</span>
<span class="fc" id="L493">                PDescriptor keyType = mapType.keyDescriptor();</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">                if (!token.isSymbol(JsonToken.kMapStart)) {</span>
<span class="fc" id="L495">                    throw new SerializerException(&quot;Invalid start of map '&quot; + token.asString() + &quot;'&quot;);</span>
                }
<span class="fc" id="L497">                PMap.Builder&lt;Object, Object&gt; map = mapType.builder();</span>

<span class="fc bfc" id="L499" title="All 2 branches covered.">                if (tokenizer.peek(&quot;map end or value&quot;).isSymbol(JsonToken.kMapEnd)) {</span>
<span class="fc" id="L500">                    tokenizer.next();</span>
                } else {
<span class="fc" id="L502">                    char sep = JsonToken.kMapStart;</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">                    while (sep != JsonToken.kMapEnd) {</span>
<span class="fc" id="L504">                        Object key = parseMapKey(tokenizer.expectString(&quot;map key&quot;)</span>
<span class="fc" id="L505">                                                          .decodeJsonLiteral(), keyType);</span>
<span class="fc" id="L506">                        tokenizer.expectSymbol(&quot;map K/V sep&quot;, JsonToken.kKeyValSep);</span>
<span class="fc" id="L507">                        Object value = parseTypedValue(tokenizer.expect(&quot;map value&quot;), tokenizer, itemType, false);</span>
<span class="pc bpc" id="L508" title="2 of 4 branches missed.">                        if (key != null &amp;&amp; value != null) {</span>
                            // In lenient mode, just drop the entire entry if the
                            // key could not be parsed. Should only be the case
                            // for unknown enum values.
                            // -- parseMapKey checked for strictRead mode.
<span class="fc" id="L513">                            map.put(key, value);</span>
                        }
<span class="fc" id="L515">                        sep = tokenizer.expectSymbol(&quot;map end or sep&quot;, JsonToken.kMapEnd, JsonToken.kListSep);</span>
<span class="fc" id="L516">                    }</span>
                }
<span class="fc" id="L518">                return map.build();</span>
            }
            case SET: {
<span class="fc" id="L521">                PDescriptor itemType = ((PSet&lt;?&gt;) t).itemDescriptor();</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">                if (!token.isSymbol(JsonToken.kListStart)) {</span>
<span class="fc" id="L523">                    throw new SerializerException(&quot;Invalid start of set '&quot; + token.asString() + &quot;'&quot;);</span>
                }
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L526">                PSet.Builder&lt;Object&gt; set = ((PSet&lt;Object&gt;) t).builder();</span>

<span class="pc bpc" id="L528" title="1 of 2 branches missed.">                if (tokenizer.peek(&quot;set end or value&quot;).isSymbol(JsonToken.kListEnd)) {</span>
<span class="nc" id="L529">                    tokenizer.next();</span>
                } else {
<span class="fc" id="L531">                    char sep = JsonToken.kListStart;</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">                    while (sep != JsonToken.kListEnd) {</span>
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">                        Object val = parseTypedValue(tokenizer.expect(&quot;set value&quot;), tokenizer, itemType, !readStrict);</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">                        if (val != null) {</span>
                            // In lenient mode, just drop the entire entry if the
                            // key could not be parsed. Should only be the case
                            // for unknown enum values.
<span class="fc" id="L538">                            set.add(val);</span>
                        }
<span class="fc" id="L540">                        sep = tokenizer.expectSymbol(&quot;set end or sep&quot;, JsonToken.kListSep, JsonToken.kListEnd);</span>
<span class="fc" id="L541">                    }</span>
                }
<span class="fc" id="L543">                return set.build();</span>
            }
            case LIST: {
<span class="fc" id="L546">                PDescriptor itemType = ((PList&lt;?&gt;) t).itemDescriptor();</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">                if (!token.isSymbol(JsonToken.kListStart)) {</span>
<span class="fc" id="L548">                    throw new SerializerException(&quot;Invalid start of list '&quot; + token.asString() + &quot;'&quot;);</span>
                }
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L551">                PList.Builder&lt;Object&gt; list = ((PList&lt;Object&gt;) t).builder();</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">                if (tokenizer.peek(&quot;list end or value&quot;).isSymbol(JsonToken.kListEnd)) {</span>
<span class="fc" id="L553">                    tokenizer.next();</span>
                } else {
<span class="fc" id="L555">                    char sep = JsonToken.kListStart;</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">                    while (sep != JsonToken.kListEnd) {</span>
<span class="fc" id="L557">                        list.add(parseTypedValue(tokenizer.expect(&quot;list value&quot;), tokenizer, itemType, false));</span>
<span class="fc" id="L558">                        sep = tokenizer.expectSymbol(&quot;list end or sep&quot;, JsonToken.kListSep, JsonToken.kListEnd);</span>
                    }
                }
<span class="fc" id="L561">                return list.build();</span>
            }
        }

<span class="nc" id="L565">        throw new SerializerException(&quot;Unhandled item type &quot; + t.getQualifiedName());</span>
    }

    private boolean isCompactible(PMessageDescriptor descriptor) {
<span class="fc bfc" id="L569" title="All 2 branches covered.">        return descriptor instanceof JsonCompactibleDescriptor &amp;&amp;</span>
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">               ((JsonCompactibleDescriptor) descriptor).isJsonCompactible();</span>
    }

    private boolean isCompact(PMessage message) {
<span class="pc bpc" id="L574" title="1 of 4 branches missed.">        return message instanceof JsonCompactible &amp;&amp; ((JsonCompactible) message).jsonCompact();</span>
    }

    private Object parseMapKey(String key, PDescriptor keyType) throws SerializerException {
        try {
<span class="pc bpc" id="L579" title="1 of 11 branches missed.">            switch (keyType.getType()) {</span>
                case BOOL:
<span class="fc bfc" id="L581" title="All 2 branches covered.">                    if (key.equalsIgnoreCase(&quot;true&quot;)) {</span>
<span class="fc" id="L582">                        return Boolean.TRUE;</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">                    } else if (key.equalsIgnoreCase(&quot;false&quot;)) {</span>
<span class="fc" id="L584">                        return Boolean.FALSE;</span>
                    }
<span class="fc" id="L586">                    throw new SerializerException(&quot;Invalid boolean value: \&quot;&quot; + Strings.escape(key) + &quot;\&quot;&quot;);</span>
                case BYTE:
<span class="fc" id="L588">                    return Byte.parseByte(key);</span>
                case I16:
<span class="fc" id="L590">                    return Short.parseShort(key);</span>
                case I32:
<span class="fc" id="L592">                    return Integer.parseInt(key);</span>
                case I64:
<span class="fc" id="L594">                    return Long.parseLong(key);</span>
                case DOUBLE:
                    try {
<span class="fc" id="L597">                        JsonTokenizer tokenizer = new JsonTokenizer(new ByteArrayInputStream(key.getBytes(</span>
                                StandardCharsets.US_ASCII)));
<span class="fc" id="L599">                        JsonToken token = tokenizer.next();</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">                        if (!token.isNumber()) {</span>
<span class="fc" id="L601">                            throw new SerializerException(&quot;Unable to parse double from key \&quot;&quot; + key + &quot;\&quot;&quot;);</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">                        } else if (tokenizer.hasNext()) {</span>
<span class="fc" id="L603">                            throw new SerializerException(&quot;Garbage after double: \&quot;&quot; + key + &quot;\&quot;&quot;);</span>
                        }
<span class="fc" id="L605">                        return token.doubleValue();</span>
<span class="fc" id="L606">                    } catch (SerializerException e) {</span>
<span class="fc" id="L607">                        throw e;</span>
<span class="fc" id="L608">                    } catch (JsonException | IOException e) {</span>
<span class="fc" id="L609">                        throw new SerializerException(e, &quot;Unable to parse double from key \&quot;&quot; + key + &quot;\&quot;&quot;);</span>
                    }
                case STRING:
<span class="fc" id="L612">                    return key;</span>
                case BINARY:
                    try {
<span class="fc" id="L615">                        return Binary.fromBase64(key);</span>
<span class="fc" id="L616">                    } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L617">                        throw new SerializerException(e, &quot;Unable to parse Base64 data&quot;);</span>
                    }
                case ENUM:
<span class="fc" id="L620">                    PEnumBuilder&lt;?&gt; eb = ((PEnumDescriptor&lt;?&gt;) keyType).builder();</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">                    if (Strings.isInteger(key)) {</span>
<span class="fc" id="L622">                        eb.setById(Integer.parseInt(key));</span>
                    } else {
<span class="fc" id="L624">                        eb.setByName(key);</span>
                    }
<span class="pc bpc" id="L626" title="1 of 4 branches missed.">                    if (readStrict &amp;&amp; !eb.valid()) {</span>
<span class="fc" id="L627">                        throw new SerializerException(&quot;\&quot;%s\&quot; is not a known enum value for %s&quot;,</span>
<span class="fc" id="L628">                                                      Strings.escape(key), keyType.getQualifiedName());</span>
                    }
<span class="fc" id="L630">                    return eb.build();</span>
                case MESSAGE:
<span class="fc" id="L632">                    PMessageDescriptor&lt;?, ?&gt; st = (PMessageDescriptor&lt;?, ?&gt;) keyType;</span>
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">                    if (!st.isSimple()) {</span>
<span class="nc" id="L634">                        throw new SerializerException(&quot;Only simple structs can be used as map key. %s is not.&quot;,</span>
<span class="nc" id="L635">                                                      st.getQualifiedName());</span>
                    }
<span class="fc" id="L637">                    ByteArrayInputStream input = new ByteArrayInputStream(key.getBytes(StandardCharsets.UTF_8));</span>
                    try {
<span class="fc" id="L639">                        JsonTokenizer tokenizer = new JsonTokenizer(input);</span>
<span class="fc" id="L640">                        if (JsonToken.kMapStart ==</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">                            tokenizer.expectSymbol(&quot;message start&quot;, JsonToken.kMapStart, JsonToken.kListStart)) {</span>
<span class="nc" id="L642">                            return parseMessage(tokenizer, st);</span>
                        } else {
<span class="fc" id="L644">                            return parseCompactMessage(tokenizer, st);</span>
                        }
<span class="fc" id="L646">                    } catch (JsonException | IOException e) {</span>
<span class="fc" id="L647">                        throw new SerializerException(e, &quot;Error parsing message key: &quot; + e.getMessage());</span>
                    }
                default:
<span class="nc" id="L650">                    throw new SerializerException(&quot;Illegal key type: %s&quot;, keyType.getType());</span>
            }
<span class="fc" id="L652">        } catch (NumberFormatException nfe) {</span>
<span class="fc" id="L653">            throw new SerializerException(nfe, &quot;Unable to parse numeric value %s&quot;, key);</span>
        }
    }

    private void appendMessage(JsonWriter writer, PMessage&lt;?,?&gt; message) throws SerializerException {
<span class="fc" id="L658">        PMessageDescriptor&lt;?, ?&gt; type = message.descriptor();</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">        if (message instanceof PUnion) {</span>
<span class="fc" id="L660">            writer.object();</span>
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">            if (((PUnion) message).unionFieldIsSet()) {</span>
<span class="fc" id="L662">                PField field = ((PUnion) message).unionField();</span>
<span class="fc" id="L663">                Object value = message.get(field.getId());</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">                if (IdType.ID.equals(fieldIdType)) {</span>
<span class="fc" id="L665">                    writer.key(field.getId());</span>
                } else {
<span class="fc" id="L667">                    writer.keyUnescaped(field.getName());</span>
                }
<span class="fc" id="L669">                appendTypedValue(writer, field.getDescriptor(), value);</span>
            }
<span class="fc" id="L671">            writer.endObject();</span>
        } else {
<span class="fc bfc" id="L673" title="All 2 branches covered.">            if (isCompact(message)) {</span>
<span class="fc" id="L674">                writer.array();</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">                for (PField field : type.getFields()) {</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">                    if (message.has(field.getId())) {</span>
<span class="fc" id="L677">                        appendTypedValue(writer, field.getDescriptor(), message.get(field.getId()));</span>
                    } else {
                        break;
                    }
                }
<span class="fc" id="L682">                writer.endArray();</span>
            } else {
<span class="fc" id="L684">                writer.object();</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">                for (PField field : type.getFields()) {</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">                    if (message.has(field.getId())) {</span>
<span class="fc" id="L687">                        Object value = message.get(field.getId());</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">                        if (IdType.ID.equals(fieldIdType)) {</span>
<span class="fc" id="L689">                            writer.key(field.getId());</span>
                        } else {
<span class="fc" id="L691">                            writer.keyUnescaped(field.getName());</span>
                        }
<span class="fc" id="L693">                        appendTypedValue(writer, field.getDescriptor(), value);</span>
                    }
                }
<span class="fc" id="L696">                writer.endObject();</span>
            }
        }
<span class="fc" id="L699">    }</span>

    private void appendTypedValue(JsonWriter writer, PDescriptor type, Object value)
            throws SerializerException {
<span class="fc bfc" id="L703" title="All 5 branches covered.">        switch (type.getType()) {</span>
            case VOID:
<span class="fc" id="L705">                writer.value(true);</span>
<span class="fc" id="L706">                break;</span>
            case MESSAGE:
<span class="fc" id="L708">                PMessage&lt;?,?&gt; message = (PMessage&lt;?,?&gt;) value;</span>
<span class="fc" id="L709">                appendMessage(writer, message);</span>
<span class="fc" id="L710">                break;</span>
            case MAP:
<span class="fc" id="L712">                writer.object();</span>

<span class="fc" id="L714">                PMap&lt;?, ?&gt; mapType = (PMap&lt;?, ?&gt;) type;</span>

<span class="fc" id="L716">                Map&lt;?, ?&gt; map = (Map&lt;?, ?&gt;) value;</span>

<span class="fc bfc" id="L718" title="All 2 branches covered.">                for (Map.Entry&lt;?, ?&gt; entry : map.entrySet()) {</span>
<span class="fc" id="L719">                    appendPrimitiveKey(writer, entry.getKey());</span>
<span class="fc" id="L720">                    appendTypedValue(writer, mapType.itemDescriptor(), entry.getValue());</span>
<span class="fc" id="L721">                }</span>

<span class="fc" id="L723">                writer.endObject();</span>
<span class="fc" id="L724">                break;</span>
            case SET:
            case LIST:
<span class="fc" id="L727">                writer.array();</span>

<span class="fc" id="L729">                PContainer&lt;?&gt; containerType = (PContainer&lt;?&gt;) type;</span>
<span class="fc" id="L730">                Collection&lt;?&gt; collection = (Collection&lt;?&gt;) value;</span>

<span class="fc bfc" id="L732" title="All 2 branches covered.">                for (Object i : collection) {</span>
<span class="fc" id="L733">                    appendTypedValue(writer, containerType.itemDescriptor(), i);</span>
<span class="fc" id="L734">                }</span>

<span class="fc" id="L736">                writer.endArray();</span>
<span class="fc" id="L737">                break;</span>
            default:
<span class="fc" id="L739">                appendPrimitive(writer, value);</span>
                break;
        }
<span class="fc" id="L742">    }</span>

    /**
     * @param writer    The writer to add primitive key to.
     * @param primitive Primitive object to get map key value of.
     */
    private void appendPrimitiveKey(JsonWriter writer, Object primitive) throws SerializerException {
<span class="fc bfc" id="L749" title="All 2 branches covered.">        if (primitive instanceof PEnumValue) {</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">            if (IdType.ID.equals(fieldIdType)) {</span>
<span class="fc" id="L751">                writer.key(((PEnumValue&lt;?&gt;) primitive).asInteger());</span>
            } else {
<span class="fc" id="L753">                writer.keyUnescaped(primitive.toString());</span>
            }
<span class="fc bfc" id="L755" title="All 2 branches covered.">        } else if (primitive instanceof Boolean) {</span>
<span class="fc" id="L756">            writer.key(((Boolean) primitive));</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">        } else if (primitive instanceof Byte) {</span>
<span class="fc" id="L758">            writer.key(((Byte) primitive));</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">        } else if (primitive instanceof Short) {</span>
<span class="fc" id="L760">            writer.key(((Short) primitive));</span>
<span class="fc bfc" id="L761" title="All 2 branches covered.">        } else if (primitive instanceof Integer) {</span>
<span class="fc" id="L762">            writer.key(((Integer) primitive));</span>
<span class="fc bfc" id="L763" title="All 2 branches covered.">        } else if (primitive instanceof Long) {</span>
<span class="fc" id="L764">            writer.key(((Long) primitive));</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">        } else if (primitive instanceof Double) {</span>
<span class="fc" id="L766">            writer.key(((Double) primitive));</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">        } else if (primitive instanceof String) {</span>
<span class="fc" id="L768">            writer.key((String) primitive);</span>
<span class="fc bfc" id="L769" title="All 2 branches covered.">        } else if (primitive instanceof Binary) {</span>
<span class="fc" id="L770">            writer.key((Binary) primitive);</span>
<span class="pc bpc" id="L771" title="1 of 2 branches missed.">        } else if (primitive instanceof PMessage) {</span>
<span class="fc" id="L772">            PMessage&lt;?,?&gt; message = (PMessage&lt;?,?&gt;) primitive;</span>
<span class="pc bpc" id="L773" title="1 of 2 branches missed.">            if (!message.descriptor().isSimple()) {</span>
<span class="nc" id="L774">                throw new SerializerException(&quot;Only simple messages can be used as map keys. &quot; +</span>
<span class="nc" id="L775">                                              message.descriptor()</span>
<span class="nc" id="L776">                                                     .getQualifiedName() + &quot; is not.&quot;);</span>
            }
<span class="fc" id="L778">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L779">            JsonWriter json = new JsonWriter(baos);</span>
<span class="fc" id="L780">            appendMessage(json, message);</span>
<span class="fc" id="L781">            json.flush();</span>
<span class="fc" id="L782">            writer.key(new String(baos.toByteArray(), StandardCharsets.UTF_8));</span>
<span class="fc" id="L783">        } else {</span>
<span class="nc" id="L784">            throw new SerializerException(&quot;illegal simple type class &quot; + primitive.getClass()</span>
<span class="nc" id="L785">                                                                                  .getSimpleName());</span>
        }
<span class="fc" id="L787">    }</span>

    /**
     * Append a primitive value to json struct.
     *
     * @param writer    The JSON writer.
     * @param primitive The primitive instance.
     */
    private void appendPrimitive(JsonWriter writer, Object primitive) throws SerializerException {
<span class="fc bfc" id="L796" title="All 2 branches covered.">        if (primitive instanceof PEnumValue) {</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">            if (IdType.ID.equals(enumValueType)) {</span>
<span class="fc" id="L798">                writer.value(((PEnumValue&lt;?&gt;) primitive).asInteger());</span>
            } else {
<span class="fc" id="L800">                writer.valueUnescaped(primitive.toString());</span>
            }
<span class="fc bfc" id="L802" title="All 2 branches covered.">        } else if (primitive instanceof Boolean) {</span>
<span class="fc" id="L803">            writer.value(((Boolean) primitive));</span>
<span class="fc bfc" id="L804" title="All 2 branches covered.">        } else if (primitive instanceof Byte) {</span>
<span class="fc" id="L805">            writer.value(((Byte) primitive));</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">        } else if (primitive instanceof Short) {</span>
<span class="fc" id="L807">            writer.value(((Short) primitive));</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">        } else if (primitive instanceof Integer) {</span>
<span class="fc" id="L809">            writer.value(((Integer) primitive));</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">        } else if (primitive instanceof Long) {</span>
<span class="fc" id="L811">            writer.value(((Long) primitive));</span>
<span class="fc bfc" id="L812" title="All 2 branches covered.">        } else if (primitive instanceof Double) {</span>
<span class="fc" id="L813">            writer.value(((Double) primitive));</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">        } else if (primitive instanceof CharSequence) {</span>
<span class="fc" id="L815">            writer.value((String) primitive);</span>
<span class="pc bpc" id="L816" title="1 of 2 branches missed.">        } else if (primitive instanceof Binary) {</span>
<span class="fc" id="L817">            writer.value((Binary) primitive);</span>
        } else {
<span class="nc" id="L819">            throw new SerializerException(&quot;illegal primitive type class &quot; + primitive.getClass()</span>
<span class="nc" id="L820">                                                                                     .getSimpleName());</span>
        }
<span class="fc" id="L822">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>